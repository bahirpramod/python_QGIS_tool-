# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RailLineDetectionTool
                                 A QGIS plugin
 this plugine used to detect distance between 2 line if distance less than 3 martk the error point
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by genesys
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.utils import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5 import QtGui
from qgis.core import *
from qgis.gui import *
from collections import *
import sys
from math import sqrt
import itertools
from qgis import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .rail_line_detection_tool_dialog import RailLineDetectionToolDialog
import os.path


class RailLineDetectionTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RailLineDetectionTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Rail Line Detection Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RailLineDetectionTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/rail_line_detection_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Rail Line Detection Tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Rail Line Detection Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = RailLineDetectionToolDialog()
            self.dlg.Cancel.clicked.connect(self.close)
            self.dlg.Ok.clicked.connect(self.getvertex)
            # self.dlg.Ok.clicked.connect(self.intersects_line)

        # show the dialog
        self.dlg.show()
        self.addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def close(self):
        self.dlg.close()
        self.dlg.progressBar.setValue(0)

    def addlayers(self):
        self.layer=QgsProject.instance().mapLayers().values()
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems([layer.name() for layer in self.layer]) 
        # print("self. layer", self.layer)

    def getvertex(self):
        self.current_layer = self.dlg.comboBox.currentText()
        # print('txt')
        for lyr in self.layer:
            layers_name = lyr.name()
            if self.current_layer == layers_name:
                # print("layers_name",layers_name)
                self.input_layer = lyr
        count = self.input_layer.selectedFeatureCount()
        if count <= 0:
                QMessageBox.information(self.dlg, "Info",
                                        " Please select the features")
                return
        value = float(self.dlg.lineEdit.text())
        # print(value)
        if str(self.input_layer.crs().authid()) == 'EPSG:4326':
            d = QgsDistanceArea()
            d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
            d.setEllipsoid(QgsProject.instance().ellipsoid())
            self.buffer1 = d.convertLengthMeasurement(value, 6)
            # print("self buffer", self.buffer1)

        else: 
            self.buffer1 = value
            # print("self buffer else ", self.buffer1)
        self.errorPointFeatures = []
        uri = "Point?crs=" + self.input_layer.crs().authid()
        vMemorylayer = QgsVectorLayer(uri, "Rail line Error", "memory")
        vMemorylayer.startEditing()
        layerData = vMemorylayer.dataProvider()
        layerData.addAttributes([QgsField("Fid", QVariant.String), QgsField("layer name", QVariant.String), QgsField("Error name", QVariant.String)])
        dctErrPnts = defaultdict()
        vertex_list=[]
        prg = 0
        for feature in self.input_layer.selectedFeatures():
            # lyr.startEditing()
            # self.dlg.progressBar.setValue(0)
            percent = prg / float(count) * 100
            self.dlg.progressBar.setValue(percent)
            prg += 1
            geom=feature.geometry()
            if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                vertex_list=geom.asMultiPolyline()[0]
            else:
                vertex_list=geom.asPolyline()
            # print("single-list",vertex_list)
            mid_vertex=vertex_list[1:-1]
            # print("mid_vertex",mid_vertex)
            for vertex in mid_vertex:
                point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
                # print("point_geom",point_geom)
                self.buffer=point_geom.buffer(self.buffer1,5)
                # print("self.buffer",self.buffer)
                bbox=self.buffer.boundingBox()
                intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
                # print("intersectFeats",intersectFeats)
                geom_list=[]
                for feat in intersectFeats:
                    # print("feat",feat)
                    if feat.id()!=feature.id():
                        # print("geom_list2")
                        if feat.geometry().intersects(feature.geometry()):
                            geom_list.append(feat)
                # print("geom_list",geom_list)

                # Distance between two vertex in the same layer
                sFeat =vertex_list[0]
                sFeat_l =vertex_list[-1]
                # print("sFeat",sFeat)
                tFeat = vertex_list[1]
                tFeat_l = vertex_list[-2]
                dist_m = sFeat.distance(tFeat)
                dist_m_l = sFeat_l.distance(tFeat_l)
                # print("dist",dist_m)
                # print("dist_l",dist_m_l)
                
                    
                name="Distance error"
                if len(geom_list)>=1:
                    if( dist_m<=self.buffer1) or (dist_m_l<=self.buffer1):
                        name="pseudo error"
                        # print("pseudo")
                        dctErrPnts[feat.id()] = [point_geom, self.input_layer.name(),name]
                    else:
                        # print("distance")
                        dctErrPnts[feat.id()] = [point_geom, self.input_layer.name(),name]


            '''Rule-2 = if at any intersect point connect gretter than 3 line then mark error point '''
        
            Fst_last_vertex=[]
            a=vertex_list[0]
            Fst_last_vertex.append(a)
            b=vertex_list[-1]
            Fst_last_vertex.append(b)
            # print("Fst_last_vertex",Fst_last_vertex)

            value = 0.0000005
            # print(value)
            if str(self.input_layer.crs().authid()) == 'EPSG:4326':
                d = QgsDistanceArea()
                d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
                d.setEllipsoid(QgsProject.instance().ellipsoid())
                self.buffer2 = d.convertLengthMeasurement(value, 6)
                # print("self buffer", self.buffer1)
            else: 
                self.buffer2 = value
                # print(value)
           
            for vertex in Fst_last_vertex:
                    point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
                    # print("point_geom",point_geom)
                    self.buffer=point_geom.buffer(self.buffer2,5)
                    # print("self.buffer",self.buffer)
                    bbox=self.buffer.boundingBox()
                    intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
                    # print("intersectFeats",intersectFeats)
                    geom_list2=[]
                    for feat in intersectFeats:
                        # print("feat",feat)
                        if feat.id()!=feature.id():
                            # print("geom_list2")
                            if feat.geometry().intersects(feature.geometry()):
                                geom_list2.append(feat)
                        # print("geom_list",geom_list2)

                        # Distance between two features in the same layer
                       

                        name="Intersect error"
                        if len(geom_list2)>=3:
                            # print("test 3 line")
                            dctErrPnts[feat.id()] = [point_geom, self.input_layer.name(),name]        
        self.iface.messageBar().pushMessage("Rail line  Error",
                                                "Snapping for " + str(self.input_layer.name()) + " layer is completed with self")
        QgsMessageLog.logMessage(
                "Rail line  Error : Snapping for " + str(self.input_layer.name()) + " layer is completed with self", "Rail line  Error",
                Qgis.Info)

        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            # print("dctErrPnts",dctErrPnts)
            # print("ids",ids)
            # print('feats',feats)
            self.updateErrorPointFeatures([ids, feats[1],feats[2]], feats[0])

        if len(dctErrPnts) > 0:
            QgsProject.instance().addMapLayer(vMemorylayer)
            layerData.addFeatures(self.errorPointFeatures)
            vMemorylayer.commitChanges()
            QMessageBox.information(None, 'Rail line  Error', 'Process completed. Error layer added')
        else:
            QMessageBox.information(None, 'Rail line  Error', 'Process completed. No error found')
            pass
    def updateErrorPointFeatures(self, attrList, point):
        # print("attrilist",attrList)
        # print("error",error)
        # print("point",point)
        newfeat = QgsFeature()
        newfeat.setAttributes(attrList)
        newfeat.setGeometry(point)
        self.errorPointFeatures.append(newfeat)






          
          
          
          
          
          
            # vertex_list=geom.asMultiPolyline()
            # print("vertex_list",vertex_list)
            # vertex_point=geom.asMultiPolyline()
            # vertex_point=geom.asPolyline()
            # vertex_list=geom.asMultiPolyline()
            # if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
            #     vertex_point=geom.asMultiPolyline()
            #     vertex_list.append(vertex_point)
            #   self.lines = [feature.geometry().asMultiPolyline() for features in feature]
            #   print("self.lines",self.lines)
            # else:
            #     vertex_point=geom.asPolyline()
            #     vertex_list.append(vertex_point)
                # self.lines = [feature.geometry().asPolyline() for features in feature]
        # print("vertex_list",vertex_list)
        # print("vertex_point",vertex_point)
        # single_list=[item for sublist in vertex_list for item in sublist]
        # single1_list=[item for sublist in single_list for item in sublist]
        # print('single1_list', single1_list)
        # print('single1_list[0]', single1_list[0])
        # print("len",len(single1_list))
        # midale_vertex=single1_list[1:-2]


        '''for vertex in single1_list:
                print("vetex",vertex)
                # print("len",len(vertex))
            # for pnt in vertex:
                # print("pnt",pnt)
                point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
                # point_geom=QgsGeometry.fromPointXY(vertex)
                # print("point_geom",point_geom)
                self.buffer=point_geom.buffer(valus,5)
                # print("self.buffer",self.buffer)
                bbox=self.buffer.boundingBox()
                intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
                # print("intersectFeats",intersectFeats)
                geom_list=[]
                for feat in intersectFeats:
                    # print("feat",feat)
                    if feat.id()!=feature.id():
                        # print("geom_list2")
                        if feat.geometry().intersects(feature.geometry()):
                            geom_list.append(feature)
                # print("geom_list",geom_list)
                if len(geom_list)>=1:
                    # print("test")
                    dctErrPnts[feat.id()] = [point_geom, self.input_layer.name()]'''








    
    #                         # for f in geom_list:
    #                         #     if self.buffer.intersects(feature.geometry()):
                                

    #                 # for intersectFeats in  lyr.getFeatures(QgsFeatureRequest(bbox)) :
    #                 # for feat in geom_list:
    #                 #     intersect_geom=feat.geometry()
    #                 # for feature in self.input_layer.selectedFeatures():
    #                 # geom=intersectFeats.geometry()
    #                 # vert_list=intersectFeats.asPolyline()
    #                 # for j in range(len(geom_list) - 1):
    #                 #     pt1=geom_list[j]
    #                 #     pt2=geom_list[j+1]
    #                 #     poly_segm=QgsGeometry.fromPolylineXY([pt1, pt2])
    #                 #     if self.buffer.intersects(poly_segm):
    #                 #         print('text')
    #         # print("geom_list",geom_list)

    #             # if self.buffer.intersects():
    #             #     pass
                
    #             # for lyr in self.layer :
    #             #     intersectFeats = [f for f in lyr.getFeatures(QgsFeatureRequest(bbox))]
    #             #     # geom_list.append(intersectFeats)
    #             #     for intsectFeat in intersectFeats:
    #             #         if intsectFeat.geometry().isMultipart():
    #             #             destLnGeom = intsectFeat.geometry().asMultiPolyline()
    #             #         else:
    #             #             destLnGeom = intsectFeat.geometry().asPolyline()
    #             #             pass
    #                     # print("geom_list",geom_list)
    #                     # # self.buffer.intersects(get_feat)
    #                     # intersectFeats = self.getIntersectFeats(lyr,bbox)
    #                     # # intersectFeats = lyr.getFeatures(QgsFeatureRequest().intersects(get_feat))
    #                     # print("intersectFeats",intersectFeats)


    #         # 
    #     # for vertex in vertex_point:
    #     #     for pnt in vertex:
    #     #         # print("pnt",pnt)
    #     #         j=0
    #     #         for j in range(len(pnt)- 1):
    #     #             j+=1
    #     #             print('j',j)
    #     #             point_geom=QgsGeometry.fromPointXY(pnt)
    #     #             self.buffer=point_geom.buffer(valus,5)
    #     #             bbox=self.buffer.boundingBox()
    #     #             get_feat = [f for f in self.current_layer.getFeatures(QgsFeatureRequest(bbox))]
    #     #             print("get_feat",get_feat)

    #                 # print("self.buffer",self.buffer)
    #                 # print("pnt",pnt)
    #                 # distance=self.getPntBndbx(point_geom)
    #                 # print("distance",distance)

    #                 # print(" point_geom", point_geom)
    # def getIntersectFeats(self,lyr, bndBox):
    #     intersectFeats = lyr.getFeatures(QgsFeatureRequest().setFilterRect(bndBox))
    #     # print(bndBox)
    #     return intersectFeats
    # def getPntBndbx(self, pnt):
    #     # print("pnt",pnt)
    #     r = self.buffer
    #     print("r",r)
    #     p = pnt
    #     print("p",p)  
    #     pointBndBox = QgsRectangle(p.x()-r,p.y()-r,p.x()+r,p.y()+r)
    #     # print("pb",pointBndBox)  
    #     return pointBndBox
    # def distance_detection(self):
    #     import itertools #To get all pairwise combinations of lines
    #     lyr = self.current_layer
    #     reproject_to = "EPSG:32633" #Change
    #     mindist = 1 #Change

        # #Reproject so distance is in meters and not degrees. Pick a coordinate system for your location
        # reprojected = processing.run("native:reprojectlayer", {'INPUT':lyr,
        #     'TARGET_CRS':QgsCoordinateReferenceSystem(reproject_to),'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

        # nearby_lines = []

        # for l1, l2 in itertools.combinations(reprojected.getFeatures(), 2):
        #     dist = l1.geometry().distance(l2.geometry())
        #     if dist <=mindist:
        #         print('{0} to {1}: {2} m'.format(l1.id(), l2.id(), round(dist,2)))
        #         nearby_lines.extend([l1.id(), l2.id()])

        # lyr.select(nearby_lines)
        # k = 0
        # for points in self.lines:
        #     n = len(points)
        #     list = range(n)
        #     print( "line" + str(k) + ", " + str(n) + " points") 
        #     length_segments = [sqrt(points[i].sqrDist(points[j])) 
        #         for i,j in itertools.combinations(list, 2) 
        #         if (j - i) == 1]
        #     sum = 0
        #     for length in length_segments:
        #         i = length_segments.index(length)
        #         print( "segment = %d, length = %.2f" % (i, length))
        #         sum += length
        #     print( "sum = ", sum)
        #     k += 1   
              