# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RailLineDetectionTool
                                 A QGIS plugin
 this plugine used to detect distance between 2 line if distance less than 3 martk the error point
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by genesys
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.utils import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5 import QtGui
from qgis.core import *
from qgis.gui import *
from collections import *
import sys
from math import sqrt
import itertools
from qgis import processing
import math
from math import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .rail_line_detection_tool_dialog import RailLineDetectionToolDialog
import os.path


class RailLineDetectionTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RailLineDetectionTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Rail Line Detection Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RailLineDetectionTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/rail_line_detection_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Rail Line Detection Tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Rail Line Detection Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = RailLineDetectionToolDialog()
            self.dlg.Cancel.clicked.connect(self.close)
            self.dlg.Ok.clicked.connect(self.getvertex)
            # self.dlg.Ok.clicked.connect(self.intersects_line)

        # show the dialog
        self.dlg.show()
        self.addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def close(self):
        self.dlg.close()
        self.dlg.progressBar.setValue(0)

    def addlayers(self):
        self.layer=QgsProject.instance().mapLayers().values()
        self.dlg.comboBox.clear()
        self.dlg.comboBox_2.clear()
        self.dlg.comboBox.addItems([layer.name() for layer in self.layer]) 
        self.dlg.comboBox_2.addItems([layer.name() for layer in self.layer]) 
        # print("self. layer", self.layer)
    


    def getvertex(self):
        self.current_layer = self.dlg.comboBox.currentText()
        # print('txt')
        for lyr in self.layer:
            layers_name = lyr.name()
            if self.current_layer == layers_name:
                # print("layers_name",layers_name)
                self.input_layer = lyr
        count = self.input_layer.selectedFeatureCount()
        if count <= 0:
                QMessageBox.information(self.dlg, "Info",
                                        " Please select the features")
                return
        MANEUVERS_layer = self.dlg.comboBox_2.currentText()
        # print('txt')MANEUVERS_sample
        for lyr in self.layer:
            layers_name = lyr.name()
            if MANEUVERS_layer == layers_name:
                # print("layers_name",layers_name)
                self.MANEUVERS_layer = lyr
                self.MANEUVERS_layer.startEditing()
        # count = self.input_layer.selectedFeatureCount()
        # if count <= 0:
        #         QMessageBox.information(self.dlg, "Info",
        #                                 " Please select the features")
        #         return
        # value = float(self.dlg.lineEdit.text())
        # # print(value)
        # if str(self.input_layer.crs().authid()) == 'EPSG:4326':
        #     d = QgsDistanceArea()
        #     d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
        #     d.setEllipsoid(QgsProject.instance().ellipsoid())
        #     self.buffer1 = d.convertLengthMeasurement(value, 6)
        #     # print("self buffer", self.buffer1)

        # else: 
        #     self.buffer1 = value
            # print("self buffer else ", self.buffer1)
        self.errorPointFeatures = []
        self.MANEUVERSFeatures = []
        # self.add_layer()
        # def add_layer(self):
        uri = "LineString?crs=" + self.input_layer.crs().authid()
        vMemorylayer2 = QgsVectorLayer(uri, "MANEUVERS_LINE", "memory")
        vMemorylayer2.startEditing()
        layerData2 = vMemorylayer2.dataProvider()
        layerData2.addAttributes([QgsField("id", QVariant.String),QgsField("SEQNR", QVariant.String), QgsField("F_EDGE", QVariant.String), QgsField("JUCTION", QVariant.String), QgsField("T_EDGE", QVariant.String),QgsField("TIPE", QVariant.String)])
        dctErrPnts2 = defaultdict()
        



        uri = "Point?crs=" + self.input_layer.crs().authid()
        vMemorylayer = QgsVectorLayer(uri, "Rail line Error", "memory")
        vMemorylayer.startEditing()
        layerData = vMemorylayer.dataProvider()
        layerData.addAttributes([QgsField("Fid", QVariant.String), QgsField("layer name", QVariant.String), QgsField("Error name", QVariant.String)])
        dctErrPnts = defaultdict()
        dctErrPnts2 = defaultdict()
        vertex_list=[]
        prg = 0
        fid=1
        # valus =5
        #     # print(valus)
        # if valus:
        #         if str(self.input_layer.crs().authid()) == 'EPSG:4326':
        #             d = QgsDistanceArea()
        #             d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
        #             d.setEllipsoid(QgsProject.instance().ellipsoid())
        #             dist_unit = QGis.UnitType(2)
        #             self.distance = d.convertLengthMeasurement(valus, dist_unit)

        #         else:
        #             self.distance = valus
        
        for feature in self.input_layer.selectedFeatures():
            # lyr.startEditing()
            # self.dlg.progressBar.setValue(0)
            percent = prg / float(count) * 100
            self.dlg.progressBar.setValue(percent)
            prg += 1
            geom=feature.geometry()
            if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                vertex_list=geom.asMultiPolyline()[0]
            else:
                vertex_list=geom.asPolyline()

            '''Rule-2 = if at any intersect point connect gretter than 3 line then mark error point '''
        
            Fst_last_vertex=[]
            a=vertex_list[0]
            # Fst_last_vertex.append(a)
            b=vertex_list[-1]
            c=vertex_list[-2]
            Fst_last_vertex.append(b)
            # print("b",b)
            az=b.azimuth(vertex_list[-2])
            az0=c.azimuth(b)
            vertex=b
         
            # for vertex in Fst_last_vertex:
            point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
            # print("point_geom",point_geom)
            self.buffer=point_geom.buffer(0.0000005,5)
            # print("self.buffer",self.buffer)
            bbox=self.buffer.boundingBox()
            intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
            geom_list2=[]
            T_JUNC_ver_list=[]
            for feat in intersectFeats:
                geom=feat.geometry()
                if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                    T_JUNC_ver=geom.asMultiPolyline()[0]
                else:
                    T_JUNC_ver=geom.asPolyline()
                f_T_JUNC_ver=(T_JUNC_ver[0])
                s_T_JUNC_ver=(T_JUNC_ver[1])
                az1=f_T_JUNC_ver.azimuth(s_T_JUNC_ver)
                angle=self.get_azimuth(az0,az1 )
                # print("angle",angle)
                # print("az0",az0)
                # print("az",az)
                # print("az1",az1)
                # print("az-az1",az-az1)
                if feat.id()!=feature.id():
                    # print("vertex",vertex)
                    # print("feature['T_JUNC']",feature['T_JUNC'])
                    # print("feat['F_JUNC']",feat['F_JUNC'])
                    if feature['T_JUNC'] == feat['F_JUNC'] and angle<165:
                        # geom_list2.append(feat)
                        # print("geom_list2 ff ",geom_list2)
                        if feat.geometry().intersects(feature.geometry()):
                            if vertex==f_T_JUNC_ver :
                                # print("vertex",vertex)
                                # print("f_T_JUNC_ver",f_T_JUNC_ver)
                                # dctErrPnts[prg] = [ point_geom, self.input_layer.name(),"before_point"]
                                az=b.azimuth(vertex_list[-2])
                                before_point=b.project(0.00005,az)
                                nearDist, queryPnt1, aftVtx1, segDirect = geom.closestSegmentWithContext(before_point)
                                d = QgsDistanceArea()
                                d.setEllipsoid('WGS84')
                                line_geom = feature.geometry()/2
                                # print("Perimeter (m):", d.measureLength(line_geom))
                                length= d.measureLength(feature.geometry())
                                l=length-5
                                print("length",l)
                                line_geom2 = feature.geometry().interpolate(l)
                                length2=d.measureLength(line_geom2)
                                print("length2",length2,line_geom2)
                                if queryPnt1 :
                                    point_geom1= QgsGeometry.fromPointXY(QgsPointXY(queryPnt1))
                                    dctErrPnts[prg+1] = [ line_geom2, self.input_layer.name(),"before_point"] 
                                next_point=b.project(0.00005,az1)
                                nearDist, queryPnt2, aftVtx1, segDirect = geom.closestSegmentWithContext(next_point)
                                if queryPnt2 :
                                    point_geom2= QgsGeometry.fromPointXY(QgsPointXY(queryPnt2))
                                    # dctErrPnts[prg+2] = [ point_geom2, self.input_layer.name(),"before_point"]
                                # print("az",az)
                                new_x = queryPnt1.x() + queryPnt2.x() - vertex.x()
                                new_y = queryPnt1.y() + queryPnt2.y() - vertex.y()
                                point_geom3=QgsPointXY(new_x, new_y)
                                point_geom4= QgsGeometry.fromPointXY(QgsPointXY(point_geom3))
                                start_point=point_geom1.asPoint()
                                end_point=point_geom4.asPoint()
                                # dctErrPnts[prg+3] = [ point_geom4, self.input_layer.name(),"before_point"]
                                # print("angle",angle)
                                if angle<105 and angle >75:
                                    dctErrPnts2[fid] = [ point_geom1,point_geom4,feature["ID_1"],feature['T_JUNC'],feat['ID_1'],1]
                                else:
                                    
                                    dctErrPnts2[fid] = [ point_geom1,point_geom4,feature["ID_1"],feature['T_JUNC'],feat['ID_1'],2]
                                fid+=1
                                # self.drawLine(point_geom1,point_geom4)
                                # print("point_geom1",point_geom1)
                                # print("point_geom4",point_geom4)
                                        
                                    

            

        for ids, feats in dctErrPnts2.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            # print("dctErrPnts2",dctErrPnts2)
            # print("ids",ids)
            # print('feats',feats)
            attrList=self.updateMANEUVERSFeatures([ids,1,feats[2],feats[3],feats[4],feats[5]], feats[0],feats[1])
        if len(dctErrPnts2) > 0:
            # print("self.MANEUVERSFeatures",len(self.MANEUVERSFeatures))
            # v_layer= self.MANEUVERS_layer
            v_layer= vMemorylayer2
            # QgsProject.instance().addMapLayer(v_layer)
            QgsProject.instance().addMapLayer(v_layer)
            layerData2 = v_layer.dataProvider()
            layerData2.addFeatures(self.MANEUVERSFeatures)
            # layerData2.changeAttributeValues(attrList)
            v_layer.updateExtents()
            v_layer.commitChanges()
        # self.update_atrri(attrList)
        
            
        QMessageBox.information(None, 'Done', 'Process completed.')
        

        

        # if len(dctErrPnts2) > 0:
        #     print("self.MANEUVERSFeatures",len(self.MANEUVERSFeatures))
        #     v_layer= self.MANEUVERS_layer
        #     # v_layer = QgsVectorLayer("LineString", "pramod", "memory")
        #     pr = v_layer.dataProvider()
        #     pr.addFeatures(self.MANEUVERSFeatures)
        #     # seg = QgsFeature()
        #     # seg.setGeometry(new_geometry)
        #     # pr.addFeatures( [ seg ] )
        #     # v_layer.updateExtents()
        #     crs = v_layer.crs()
        #     crs.createFromId(4326)
        #     v_layer.setCrs(crs)
        #     # QgsProject.instance().addMapLayers([v_layer])
        #     # QgsProject.instance().addMapLayer(v_layer)
        #     # pr.addFeatures(self.MANEUVERSFeatures)
        #     v_layer.commitChanges()
            # QMessageBox.information(None, 'Rail line  Error', 'Process completed. Error layer added')
        # else:
        #     QMessageBox.information(None, 'Rail line  Error', 'Process completed. No error found')
        #     pass

        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            # print("dctErrPnts",dctErrPnts)
            # print("ids",ids)
            # print('feats',feats)
            self.updateErrorPointFeatures([ ids, feats[1],feats[2]], feats[0])
        if len(dctErrPnts) > 0:
            print("self.errorPointFeatures",len(self.errorPointFeatures))
            QgsProject.instance().addMapLayer(vMemorylayer)
            layerData.addFeatures(self.errorPointFeatures)
            vMemorylayer.updateExtents()
            vMemorylayer.commitChanges()
            QMessageBox.information(None, 'Done', 'Process completed.')
        # else:
        #     QMessageBox.information(None, 'Done', 'Process completed.')
        #     pass

        

    def updateMANEUVERSFeatures(self, attrList, start,end):
        # print("attrilist",attrList)
        # self.pnt=point
        # print("error",error)
        # print("point",point)
        start_point=start.asPoint()
        end_point=end.asPoint()
        # print("start_point",start_point)
        # print("end_point",end_point)
        newfeat = QgsFeature()
        newfeat.setAttributes(attrList)
        line_geometry = QgsGeometry.fromPolylineXY([start_point, end_point]) 
        new_geometry = QgsGeometry(line_geometry)
        newfeat.setGeometry(new_geometry)
        self.MANEUVERSFeatures.append(newfeat)
        return attrList
    def update_atrri(self,attrList):
            #    for ids, feats in dctErrPnts2.items():
            print("attrilist",attrList)
            for feature in self.MANEUVERS_layer.getFeatures():
                for fields in feature.fields():
                    field_name=str(fields.name())
                    # fields_name=field_name.lower()
                    # print("fields_name",fields_name)
                    if field_name=="F_EDGE":
                        # feature['F_EDGE'] = attrList[0]
                        # self.MANEUVERS_layer.updateFeature(feature)
                        print("1234")
                        field_idx = self.MANEUVERS_layer.fields().indexOf('F_EDGE')
                        self.MANEUVERS_layer.changeAttributeValue(feature.id(), field_idx, attrList[0])
                        self.MANEUVERS_layer.commitChanges()
    def get_azimuth(self, az1,az2):
        if az1>0:
            angle=(az2-az1)+180
            if angle<0:
                angle=-angle
            if angle>180:
                angle=360-angle
            # print(">")
        else :
            angle=(az2-az1)+180
            if angle>180:
                angle=360-angle
            if angle<0:
                angle=-angle
        return angle
        # Calculate the azimuth of the line geometry.
        # line = geometry.asPolyline()
        # line = point
        # x1, y1, x2, y2 = line[0].x(), line[0].y(), line[-1].x(), line[-1].y()
        # angle = atan2(x2 - x1, y2 - y1)
        # # Convert radians to degrees.
        # return degrees(angle)
       


    def updateErrorPointFeatures(self, attrList, point):
        print("attrilist",attrList)
        self.pnt=point
        # print("error",error)
        # print("point",point)
        newfeat = QgsFeature()
        newfeat.setAttributes(attrList)
        newfeat.setGeometry(point)
        self.errorPointFeatures.append(newfeat)

    def drawLine(self, start, end):
        distance=0.00005
        line_start=start.asPoint()
        line_end=end.asPoint()
        # dir=(az1/az1)
        print("dir",dir)
        # print("az1",az1)
        # point_geom = QgsGeometry.fromPointXY(point_geom)
        line_geometry = QgsGeometry.fromPolylineXY([line_start, line_end]) 
        new_geometry = QgsGeometry(line_geometry)  
        # new_geometry.moveVertex(point_geom, 0)     
        v_layer = QgsVectorLayer("LineString", "pramod", "memory")
        pr = v_layer.dataProvider()
        seg = QgsFeature()
        seg.setGeometry(new_geometry)
        pr.addFeatures( [ seg ] )
        v_layer.updateExtents()
        crs = v_layer.crs()
        crs.createFromId(4326)
        v_layer.setCrs(crs)
        QgsProject.instance().addMapLayers([v_layer])
    
    def add_layer(self):
        uri = "LineString?crs=" + self.input_layer.crs().authid()
        vMemorylayer2 = QgsVectorLayer(uri, "MANEUVERS_LINE", "memory")
        vMemorylayer2.startEditing()
        layerData2 = vMemorylayer2.dataProvider()
        layerData2.addAttributes([QgsField("Fid", QVariant.String), QgsField("F_EDGE", QVariant.String), QgsField("JUCTION", QVariant.String), QgsField("T_EDGE", QVariant.String)])
        # dctErrPnts = defaultdict()








          
          
          # print("nearDist, queryPnt1, aftVtx1, segDirect",nearDist, queryPnt1, aftVtx1, segDirect)
                                        # point= QgsGeometry.fromPointXY(QgsPointXY(queryPnt1))
                                        # distance = nearDist
                                        # if distance < nearest_distance:
                                        #     nearest_line_point = queryPnt1
                                        # # print("nearest_line_point",nearest_line_point)
                                        # d = QgsDistanceArea()
                                        # d.setEllipsoid('WGS84')
                                        # line_geom = feature.geometry()
                                        # nearest_point = feature.geometry().nearestPoint(point)
                                        # print("nearest_point:", nearest_point)
                                        # length= d.measureLength(feature.geometry())
                                        # l=length-5
                                        # # point=self.gen_point(self.input_layer,l)
                                        # # print("point",point)
                                        # line_geom2 = feature.geometry().interpolate(l)
                                        # length2=d.measureLength(line_geom2)
                                        # # print("length2",length2,line_geom2)
          
          
          
            # vertex_list=geom.asMultiPolyline()
            # print("vertex_list",vertex_list)
            # vertex_point=geom.asMultiPolyline()
            # vertex_point=geom.asPolyline()
            # vertex_list=geom.asMultiPolyline()
            # if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
            #     vertex_point=geom.asMultiPolyline()
            #     vertex_list.append(vertex_point)
            #   self.lines = [feature.geometry().asMultiPolyline() for features in feature]
            #   print("self.lines",self.lines)
            # else:
            #     vertex_point=geom.asPolyline()
            #     vertex_list.append(vertex_point)
                # self.lines = [feature.geometry().asPolyline() for features in feature]
        # print("vertex_list",vertex_list)
        # print("vertex_point",vertex_point)
        # single_list=[item for sublist in vertex_list for item in sublist]
        # single1_list=[item for sublist in single_list for item in sublist]
        # print('single1_list', single1_list)
        # print('single1_list[0]', single1_list[0])
        # print("len",len(single1_list))
        # midale_vertex=single1_list[1:-2]


        '''for vertex in single1_list:
                print("vetex",vertex)
                # print("len",len(vertex))
            # for pnt in vertex:
                # print("pnt",pnt)
                point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
                # point_geom=QgsGeometry.fromPointXY(vertex)
                # print("point_geom",point_geom)
                self.buffer=point_geom.buffer(valus,5)
                # print("self.buffer",self.buffer)
                bbox=self.buffer.boundingBox()
                intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
                # print("intersectFeats",intersectFeats)
                geom_list=[]
                for feat in intersectFeats:
                    # print("feat",feat)
                    if feat.id()!=feature.id():
                        # print("geom_list2")
                        if feat.geometry().intersects(feature.geometry()):
                            geom_list.append(feature)
                # print("geom_list",geom_list)
                if len(geom_list)>=1:
                    # print("test")
                    dctErrPnts[feat.id()] = [point_geom, self.input_layer.name()]'''








    
    #                         # for f in geom_list:
    #                         #     if self.buffer.intersects(feature.geometry()):
                                

    #                 # for intersectFeats in  lyr.getFeatures(QgsFeatureRequest(bbox)) :
    #                 # for feat in geom_list:
    #                 #     intersect_geom=feat.geometry()
    #                 # for feature in self.input_layer.selectedFeatures():
    #                 # geom=intersectFeats.geometry()
    #                 # vert_list=intersectFeats.asPolyline()
    #                 # for j in range(len(geom_list) - 1):
    #                 #     pt1=geom_list[j]
    #                 #     pt2=geom_list[j+1]
    #                 #     poly_segm=QgsGeometry.fromPolylineXY([pt1, pt2])
    #                 #     if self.buffer.intersects(poly_segm):
    #                 #         print('text')
    #         # print("geom_list",geom_list)

    #             # if self.buffer.intersects():
    #             #     pass
                
    #             # for lyr in self.layer :
    #             #     intersectFeats = [f for f in lyr.getFeatures(QgsFeatureRequest(bbox))]
    #             #     # geom_list.append(intersectFeats)
    #             #     for intsectFeat in intersectFeats:
    #             #         if intsectFeat.geometry().isMultipart():
    #             #             destLnGeom = intsectFeat.geometry().asMultiPolyline()
    #             #         else:
    #             #             destLnGeom = intsectFeat.geometry().asPolyline()
    #             #             pass
    #                     # print("geom_list",geom_list)
    #                     # # self.buffer.intersects(get_feat)
    #                     # intersectFeats = self.getIntersectFeats(lyr,bbox)
    #                     # # intersectFeats = lyr.getFeatures(QgsFeatureRequest().intersects(get_feat))
    #                     # print("intersectFeats",intersectFeats)


    #         # 
    #     # for vertex in vertex_point:
    #     #     for pnt in vertex:
    #     #         # print("pnt",pnt)
    #     #         j=0
    #     #         for j in range(len(pnt)- 1):
    #     #             j+=1
    #     #             print('j',j)
    #     #             point_geom=QgsGeometry.fromPointXY(pnt)
    #     #             self.buffer=point_geom.buffer(valus,5)
    #     #             bbox=self.buffer.boundingBox()
    #     #             get_feat = [f for f in self.current_layer.getFeatures(QgsFeatureRequest(bbox))]
    #     #             print("get_feat",get_feat)

    #                 # print("self.buffer",self.buffer)
    #                 # print("pnt",pnt)
    #                 # distance=self.getPntBndbx(point_geom)
    #                 # print("distance",distance)

    #                 # print(" point_geom", point_geom)
    # def getIntersectFeats(self,lyr, bndBox):
    #     intersectFeats = lyr.getFeatures(QgsFeatureRequest().setFilterRect(bndBox))
    #     # print(bndBox)
    #     return intersectFeats
    # def getPntBndbx(self, pnt):
    #     # print("pnt",pnt)
    #     r = self.buffer
    #     print("r",r)
    #     p = pnt
    #     print("p",p)  
    #     pointBndBox = QgsRectangle(p.x()-r,p.y()-r,p.x()+r,p.y()+r)
    #     # print("pb",pointBndBox)  
    #     return pointBndBox
    # def distance_detection(self):
    #     import itertools #To get all pairwise combinations of lines
    #     lyr = self.current_layer
    #     reproject_to = "EPSG:32633" #Change
    #     mindist = 1 #Change

        # #Reproject so distance is in meters and not degrees. Pick a coordinate system for your location
        # reprojected = processing.run("native:reprojectlayer", {'INPUT':lyr,
        #     'TARGET_CRS':QgsCoordinateReferenceSystem(reproject_to),'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

        # nearby_lines = []

        # for l1, l2 in itertools.combinations(reprojected.getFeatures(), 2):
        #     dist = l1.geometry().distance(l2.geometry())
        #     if dist <=mindist:
        #         print('{0} to {1}: {2} m'.format(l1.id(), l2.id(), round(dist,2)))
        #         nearby_lines.extend([l1.id(), l2.id()])

        # lyr.select(nearby_lines)
        # k = 0
        # for points in self.lines:
        #     n = len(points)
        #     list = range(n)
        #     print( "line" + str(k) + ", " + str(n) + " points") 
        #     length_segments = [sqrt(points[i].sqrDist(points[j])) 
        #         for i,j in itertools.combinations(list, 2) 
        #         if (j - i) == 1]
        #     sum = 0
        #     for length in length_segments:
        #         i = length_segments.index(length)
        #         print( "segment = %d, length = %.2f" % (i, length))
        #         sum += length
        #     print( "sum = ", sum)
        #     k += 1   
              