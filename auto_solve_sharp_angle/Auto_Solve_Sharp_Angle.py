# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AutoSolveSharpAngle
                                 A QGIS plugin
 Need to create smooth data wherever there is Notches. Tolerance- Restriction basis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Genesys
        email                : pramoddb@email.igenesys.com; 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.utils import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5 import QtGui
from qgis.core import *
from qgis.gui import *
from collections import *
import sys
import math
import itertools
from qgis import processing
from qgis.core import QgsGeometry, QgsGeometryUtils

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Auto_Solve_Sharp_Angle_dialog import AutoSolveSharpAngleDialog
import os.path


class AutoSolveSharpAngle:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AutoSolveSharpAngle_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Auto Solve Sharp Angle')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AutoSolveSharpAngle', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Auto_Solve_Sharp_Angle/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Auto Solve Sharp Angle'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Auto Solve Sharp Angle'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = AutoSolveSharpAngleDialog()
            self.dlg.Cancel.clicked.connect(self.close)
            self.dlg.Ok.clicked.connect(self.find_angle)

        # show the dialog
        self.dlg.show()
        self.addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
    
    def close(self):
        self.dlg.close()
        self.dlg.progressBar.setValue(0)
    
    def addlayers(self):
        self.layer=QgsProject.instance().mapLayers().values()
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems([layer.name() for layer in self.layer])

    def find_angle(self):
        self.current_layer = self.dlg.comboBox.currentText()
        for lyr in self.layer:
            layers_name = lyr.name()
            if self.current_layer == layers_name:
                self.input_layer = lyr
                self.input_layer.startEditing()
                # self.current_layer.commitChanges()
        count = self.input_layer.selectedFeatureCount()
        if count <= 0:
                QMessageBox.information(self.dlg, "Info",
                                        " Please select the features")
                return
        self.angle_1=self.dlg.lineEdit.text()
        self.angle_2=self.dlg.lineEdit_2.text()
        # distance=self.dlg.lineEdit_3.text() 
        valus = eval(self.dlg.lineEdit_3.text()) 
            # print(valus)
        if valus:
                if str(self.input_layer.crs().authid()) == 'EPSG:4326':
                    d = QgsDistanceArea()
                    d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
                    d.setEllipsoid(QgsProject.instance().ellipsoid())
                    self.distance = d.convertLengthMeasurement(valus, 6)

                else:
                    self.distance = valus
        if not self.angle_1.isdigit() and self.angle_2 :
                QMessageBox.information(self.dlg, "Info",
                                   " Please Enter Valid Angle")
        
        vertex_list=[]
        subpolylines=[]
        subpolylines = []
        prg = 0
        j=0
        k=0
        # for lyr in self.input_layer.selectedFeatures():
        # print("self.input_layer",self.input_layer)
        for feature in self.input_layer.selectedFeatures():
            self.newlay()
            self.v2.startEditing()
            self.addlayer()
            self.v1.startEditing()
            # src_layer.append(feature)
                # lyr.startEditing()
            # print("Feature name")
            percent = prg / float(count) * 100
            self.dlg.progressBar.setValue(percent)
            prg += 1
            j+=1
            geom=feature.geometry()
            ft = QgsFeature()
            ft.initAttributes(2)
            ft.setAttributes([j, 'line layer'])
            ft.setGeometry(geom)
            self.v1.addFeatures([ft])
            # print("geom",geom)
            if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                vertex_list=geom.asMultiPolyline()[0]
            else:
                vertex_list=geom.asPolyline()
            # vertex_list=geom.asMultiPolyline()
            # print("vertex_list",vertex_list)
            count=len(vertex_list)
            # print("count",count)
            for a in range(count- 2):
                # print("a",a)
                v1 = vertex_list[a]
                v2 = vertex_list[a + 1]
                v3 = vertex_list[a + 2]
                a+=a
                az1 = v1.azimuth(v2)
                # print('az1', az1)
                az2 = v2.azimuth(v3)
                # print('az2', az2)
                if az1>0:
                    angle=(az2-az1)+180
                    if angle<0:
                        angle=-angle
                    if angle>180:
                        angle=360-angle
                    # print(">")
                else :
                    angle=(az2-az1)+180
                    if angle>180:
                        angle=360-angle
                    if angle<0:
                        angle=-angle
                # print(" angle ", angle)
                if angle > int(self.angle_1) and angle <  int(self.angle_2) :
                    # l=QgsDistanceArea().measureLine(v1,v2)
                    # print("l",l)
                    d1=v1.distance(v2)
                    d2=v3.distance(v2)
                    # print("d1",d1)
                    # print("d2",d2)
                    if self.distance<d1 or self.distance<d2:
                        k += 1
                        # print("v2", v2)
                        pt_geom1 = QgsGeometry.fromPointXY(v2) 
                        ft1 = QgsFeature()
                        ft1.initAttributes(2)
                        ft1.setAttributes([k, 'angle error'])
                        ft1.setGeometry(pt_geom1)
                        self.v2.addFeatures([ft1])
                    else:
                        pass
                    az3=v2.azimuth(v1)
                    az4=v2.azimuth(v3)
                    # print("az3",az3)
                    # print("az4",az4)
                    before_point=v2.project(self.distance,az3)
                    next_point=v2.project(self.distance,az4)
                    # print('before point', before_point)
                    # print('next_point', next_point)
                    nearDist, queryPnt1, aftVtx1, segDirect = geom.closestSegmentWithContext(before_point)
                    nearDist, queryPnt2, aftVtx2, segDirect = geom.closestSegmentWithContext(next_point)
                    # print("av",aftVtx2)
                    pt_geom1 = QgsGeometry.fromPointXY(before_point) 
                    ft1 = QgsFeature()
                    ft1.initAttributes(2)
                    ft1.setAttributes([k+1, 'angle error'])
                    ft1.setGeometry(pt_geom1)
                    self.v2.addFeatures([ft1])
                    pt_geom1 = QgsGeometry.fromPointXY(next_point) 
                    ft1 = QgsFeature()
                    ft1.initAttributes(2)
                    ft1.setAttributes([k+2, 'angle error'])
                    ft1.setGeometry(pt_geom1)
                    self.v2.addFeatures([ft1])

                    if queryPnt1 :
                        # print("querrypnt",queryPnt1)
                        az5=queryPnt1.azimuth(v2)
                        az6=queryPnt1.azimuth(v1)
                        f_pt=queryPnt1.project(self.distance,(az5-90))
                        s_pt=queryPnt1.project(self.distance,(az6-90))
                        self.v1.splitFeatures([f_pt,s_pt])
                       
                        # self.input_layer.splitFeatures([f_pt,s_pt]) #orignal geom change 
                    
                    if queryPnt2 :
                        # print("text")
                        az7=queryPnt2.azimuth(v3)
                        az8=queryPnt2.azimuth(v2)
                        f_pt1=queryPnt2.project(self.distance,(az7-90))
                        s_pt1=queryPnt2.project(self.distance,(az8-90))
                        self.v1.splitFeatures([f_pt1,s_pt1])
                        # self.input_layer.splitFeatures([f_pt1,s_pt1]) #orignal geom change
                        # pt_geom1 = QgsGeometry.fromPolylineXY([f_pt1,s_pt1]) 
                        # # self.input_layer.splitFeatures(QgsPointXY[pt_geom1])
                        # ft = QgsFeature()
                        # ft.initAttributes(2)
                        # ft.setAttributes([j, 'angle error'])
                        # ft.setGeometry(pt_geom1)
                        # self.v1.addFeatures([ft])
                            
                    # for ly in self.input_layer.getFeatures(): #orignal geom change
                    for ly in self.v1.getFeatures():
                        # print("ly",ly)
                        geom1=ly.geometry()
                        value = 0.0005
                        if str(self.input_layer.crs().authid()) == 'EPSG:4326':
                            d = QgsDistanceArea()
                            d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
                            d.setEllipsoid(QgsProject.instance().ellipsoid())
                            val = d.convertLengthMeasurement(value, 6)
                            # print("self buffer", self.buffer1)
                        else: 
                            val = value
                        pnt_1=QgsGeometry.fromPointXY(queryPnt1).buffer(val,5)
                        pnt_2=QgsGeometry.fromPointXY(queryPnt2).buffer(val,5)
                        if pnt_1.intersects(geom1) and pnt_2.intersects(geom1):
                            # print("goem1", geom1)
                            smoothed_geometry=geom1.smooth(4)
                            self.v1.changeGeometry(ly.id(), smoothed_geometry)
                            # self.input_layer.changeGeometry(ly.id(), smoothed_geometry) #orignal geom change
                            # simplified_geom = geom1.simplify()
                            # self.v1.changeGeometry(ly.id(), simplified_geom)
                        marge_geom=[]
                        for lyr in self.v1.getFeatures():
                            geom= lyr.geometry()
                            marge_geom.append(geom)
                        union_geom=QgsGeometry.unaryUnion(marge_geom)
                        new_geom=union_geom.mergeLines()	 
                        # print("new_geom",new_geom)
                        self.input_layer.changeGeometry(feature.id(),new_geom)
        if j <= 0:
            QMessageBox.information(self.dlg, "Info",
                                    " Errors Not Found")
        else:
            QgsProject.instance().addMapLayer(self.v1)
            QgsProject.instance().addMapLayer(self.v2)
            QMessageBox.information(self.dlg, "Info",
                                    " Errors Marked Successfully")
        # if k <= 0:
        #     QMessageBox.information(self.dlg, "Info",
        #                             " Errors Not Found")
        # else:
        #     QgsProject.instance().addMapLayer(self.v2)
        #     QMessageBox.information(self.dlg, "Info",
        #                             " Errors Marked Successfully")
            

    def newlay(self):
        self.v2 = QgsVectorLayer("Point", "angle_error_points", "memory")
        # print("vl",self.vl)
        self.v2.startEditing()
        pr = self.v2.dataProvider()
        # print("pr",pr)
        pr.addAttributes([QgsField("id1", QVariant.String),
                          QgsField("Discription1", QVariant.String)])
        self.v2.commitChanges()            

    def addlayer(self):
        self.v1 = QgsVectorLayer("LineString?crs=epsg:self.input_layer.crs()", "line layer", "memory")
        # print("vl",self.vl)
        self.v1.startEditing()
        pr = self.v1.dataProvider()
        # print("pr",pr)
        pr.addAttributes([QgsField("id", QVariant.String),
                          QgsField("Discription", QVariant.String)])
        self.v1.commitChanges() 
    # def cut(self, distance, lines):
    # # Cuts a line in several segments at a distance from its starting point
    #     if distance <= 0.0 or distance >= line.length:
    #         return [LineString(line)]
    #     coords = list(line.coords)
    #     for i, p in enumerate(coords):
    #         pd = line.project(Point(p))
    #         if pd == distance:
    #             return [
    #                 LineString(coords[:i+1]),
    #                 LineString(coords[i:])
    #                 ]
    #         if pd > distance:
    #             cp = line.interpolate(distance)
    #             lines.append(LineString(coords[:i] + [(cp.x, cp.y)]))
    #             line = LineString([(cp.x, cp.y)] + coords[i:])
    #             if line.length > distance:
    #                 cut(line, distance, lines)
    #             else:
    #                 lines.append(LineString([(cp.x, cp.y)] + coords[i:]))
    #             return lines
                

            
   
            