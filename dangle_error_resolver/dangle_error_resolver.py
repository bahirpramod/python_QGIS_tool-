# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DangleErrorResolver
                                 A QGIS plugin
 This plugin is used for dangle error resolver
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Genesys
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.utils import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5 import QtGui
from qgis.core import *
from qgis.gui import *
from collections import *
import random
import sys

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .dangle_error_resolver_dialog import DangleErrorResolverDialog
import os.path


class DangleErrorResolver:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.srcLnLayer = None
        self.buffer = None
        self.refFeatdict = None
        self.srcFeatdict = None
        self.errorPointFeatures = []
        self.canvasLayers = None
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DangleErrorResolver_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Dangle Error Resolver')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DangleErrorResolver', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)
 
        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/dangle_error_resolver/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'This plugin is used for dangle error resolver'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Dangle Error Resolver'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = DangleErrorResolverDialog()
            self.dlg.cancel.clicked.connect(self.close)
            self.dlg.ok.clicked.connect(self.find_dangle_error)

        # show the dialog
        # self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg.show()
        self.addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass


    def close(self):
        self.dlg.close()
        self.dlg.progressBar.setValue(0)
        pass


    def addlayers(self):
        self.layer=QgsProject.instance().mapLayers().values()
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems([layer.name() for layer in self.layer])
        # add_layers = []
        # for l in self.layer:
        #     layers_name = l.name()
        #     # print(l.geometryType())
        #     if l.geometryType()==1 or l.geometryType()==2:
        #         add_layers.append(layers_name)

        # self.dlg.comboBox.addItems(add_layers)
       
        

  
    # progressBar
    def find_dangle_error(self):
        try:
            txt = self.dlg.comboBox.currentText()
            # print(txt)
            for l in self.layer:
                layers_name = l.name()
                if txt == layers_name:
                    # print("layers_name",layers_name)
                    input_layer = l
     


            # i = 0
            # count = input_layer.featureCount()
            # for feat in input_layer.selectedFeatures():
            #     i += 1
            #     percent = i / float(count) * 100
            #     self.dlg.progressBar.setValue(percent)
            #     print("feat", feat)

            # try:
            count = input_layer.selectedFeatureCount()
            if count <= 0:
                QMessageBox.information(self.dlg, "Info",
                                        " Please select the features")
                return

            # result = QMessageBox.warning(None, "Waring",
            #                              "Solve Multipart Geometries Error Before Proceeding.\nClick Ok to continue",
            #                              QMessageBox.Ok | QMessageBox.Cancel, QMessageBox.Cancel)
            # if result == QMessageBox.Cancel:
            #     return
            num = 0
            self.srcLnLayer = input_layer
            if self.srcLnLayer:
                # self.layer.editingStopped.connect(self.toggleOff)
                if self.srcLnLayer.type() != QgsMapLayer.VectorLayer:
                    self.iface.messageBar().pushInfo("Dangle Error:", "Select vector layer only!")
                    return
                if self.srcLnLayer.geometryType() != 1:
                    self.iface.messageBar().pushInfo("Dangle Error:", "Select line or polygon layer only!")
                    return
                
            #split feature 
            self.current_layer = self.dlg.comboBox.currentText()
            # print('txt')
            for lyr in self.layer:
                layers_name = lyr.name()
                if self.current_layer == layers_name:
                    # print("layers_name",layers_name)
                    self.input_layer = lyr
            count = self.input_layer.selectedFeatureCount()
            if count <= 0:
                    QMessageBox.information(self.dlg, "Info",
                                            " Please select the features")
                    return
            # value = float(self.dlg.lineEdit.text())
            # # print(value)
            # if str(self.input_layer.crs().authid()) == 'EPSG:4326':
            #     d = QgsDistanceArea()
            #     d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
            #     d.setEllipsoid(QgsProject.instance().ellipsoid())
            #     self.buffer1 = d.convertLengthMeasurement(value, 6)
                # print("self buffer", self.buffer1)

            # else: 
            #     self.buffer1 = value
                # print("self buffer else ", self.buffer1)
            # self.errorPointFeatures = []
            # uri = "Point?crs=" + self.input_layer.crs().authid()
            # vMemorylayer = QgsVectorLayer(uri, "Rail line Error", "memory")
            # vMemorylayer.startEditing()
            # layerData = vMemorylayer.dataProvider()
            # layerData.addAttributes([QgsField("Fid", QVariant.String), QgsField("layer name", QVariant.String), QgsField("Error name", QVariant.String)])
            # dctErrPnts = defaultdict()

            
            # vertex_list=[]
            # for feature in self.input_layer.selectedFeatures():
            #     geom=feature.geometry()
            #     vertex_list=geom.asMultiPolyline()[0]
            #     if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
            #         vertex_list=geom.asMultiPolyline()[0]
            #     else:
            #         vertex_list=geom.asPolyline()
            # # print(" vertex_list",  vertex_list)
            #     Fst_last_vertex=[]
            #     a=vertex_list[0]
            #     Fst_last_vertex.append(a)
            #     b=vertex_list[-1]
            #     Fst_last_vertex.append(b)
            #     print("Fst_last_vertex",Fst_last_vertex)

            #     value = 1
            #     # print(value)
            #     if str(self.input_layer.crs().authid()) == 'EPSG:4326':
            #         d = QgsDistanceArea()
            #         d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
            #         d.setEllipsoid(QgsProject.instance().ellipsoid())
            #         self.buffer2 = d.convertLengthMeasurement(value, 6)
            #         # print("self buffer", self.buffer1)
            #     else: 
            #         self.buffer2 = value
            #         # print(value)
            
            #     for vertex in Fst_last_vertex:
            #             print("vertex",vertex)
            #             point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
            #             # print("point_geom",point_geom)
            #             self.buffer=point_geom.buffer(self.buffer2,6)
            #             # print("self.buffer",self.buffer)
            #             bbox=self.buffer.boundingBox()
            #             intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
            #             # print("intersectFeats",intersectFeats)
            #             geom_list2=[]
            #             for feat in intersectFeats:
            #                 # point_geom = QgsGeometry.fromPointXY(QgsPointXY(feat))
            #                 # print("point_geom",point_geom)
            #                 # print("feat.id()",feat)
            #                 # print("feature.id()",feature.id())
            #                 if feat.id()!=feature.id():
            #                     # print("geom_list2")
            #                     if feature.geometry().intersects(feat.geometry()):
            #                         # self.input_layer.splitFeatures()
            #                         print("one line")
            #                         geom_list2.append(feat)
            #                 print("geom_list 2",geom_list2)

            #                 # Distance between two features in the same layer
                        

            #                 # name="Intersect error"
            #                 if len(geom_list2)<=1:
            #                     nearDist, queryPnt, aftVtx, segDirect = geom.closestSegmentWithContext(vertex)
            #                     print("queryPnt",queryPnt)
            #                     pass
            #                     self.input_layer.splitFeatures([queryPnt])
            #                     print("one line")

            self.refFeatdict = defaultdict()
            self.srcFeatdict = defaultdict()
            self.errorPointFeatures = []
            valus = float(self.dlg.lineEdit.text())
            # self.buffer = valus
            # print(valus)
            if valus<=2.0:
                if str(self.srcLnLayer.crs().authid()) == 'EPSG:4326':
                    # from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform
                    # src_crs = QgsCoordinateReferenceSystem(3857)
                    # dst_crs = QgsCoordinateReferenceSystem(4326)
                    # coord_transform = QgsCoordinateTransform(src_crs, dst_crs, QgsProject.instance())
                    # self.buffer = coord_transform.convertLengthMeasurement(valus, 0)


                    d = QgsDistanceArea()
                    d.setSourceCrs(self.srcLnLayer.crs(), QgsProject.instance().transformContext())
                    d.setEllipsoid(QgsProject.instance().ellipsoid())
                    self.buffer = d.convertLengthMeasurement(valus, 6)
                    # self.buffer = valus
                    print("self.buffer", self.buffer)

                else:
                    self.buffer = valus
                    print("self.buffer else", self.buffer)
            else :
                QMessageBox.information(self.dlg,"info", "pleasse enter value less than equal 2 !")
                return 
                
            uri = "Point?crs=" + self.srcLnLayer.crs().authid()
            vMemorylayer = QgsVectorLayer(uri, "DangleError", "memory")
            vMemorylayer.startEditing()
            layerData = vMemorylayer.dataProvider()
            layerData.addAttributes([QgsField("Fid", QVariant.String), QgsField("layer name", QVariant.String)])
            num = self.getSrcLineFeatures()
            # self.getRefLineFeatures()
            # print("self.srcFeatdict",self.srcFeatdict)

            # start Iterrating
            
            dctErrPnts = defaultdict()
            print(defaultdict())
            for lyr, featList in self.srcFeatdict.items():
                # print("featlist lyr",featList,lyr)
                prg = 0
                lyr.startEditing()
                for feat_ in featList:
                    # print("feat",feat_)
                    percent = prg / float(count) * 100
                    self.dlg.progressBar.setValue(percent)
                    prg += 1
                    fid = feat_.id()
                    feat = lyr.getFeature(fid)
                    # print("feat",feat)
                    if feat.geometry().isMultipart():
                        srcLnGeom = feat.geometry().asMultiPolyline()[0]
                    else:
                        srcLnGeom = feat.geometry().asPolyline()
                    # print("srcLnGeom",srcLnGeom)
                    srcStartPnt = srcLnGeom[0]
                    # print("srcStartPnt ",srcStartPnt )
                    srcEndPnt = srcLnGeom[-1]
                    # print("srcEndPnt",srcEndPnt)
                    srcStartPnt1 = QgsGeometry(QgsGeometry().fromPointXY(srcLnGeom[0]))
                    srcEndPnt1 = QgsGeometry(QgsGeometry().fromPointXY(srcLnGeom[-1]))
                    # print(srcStartPnt)    #'''get  move line point  +-1''
                    # print(srcEndPnt)      #'''get  move line point  +-1''
                    # print("srcStartPnt1s",srcStartPnt1)    #'''get  move line point  +-1''
                    # print("srcEndPnt1s",srcEndPnt1)  #'''get  move line point  +-1'''  
                    

                    bndBox = self.getPntBndbx(srcStartPnt)
                    # print("bndBox",bndBox)   # get  move line +- buffer point and show point
                    # lyr.changeGeometry(feat.id(), QgsGeometry().fromRect(bndBox))
                    # break
                    intersectFeats, featCount = self.getIntersectFeats(lyr, bndBox)
                    # print("intersectFeats",intersectFeats)  # get adresss
                    # print("featCount",featCount) # get select feat count
                    lyr.removeSelection()
                    stPntMatched = []
                    endPntMatched = []
                    stDestEndPntNotMatched = []
                    enDestStPntNotMatched = []
                    stPntCnter = 0
                    stPntDestMatched = []
                    stPntDestPnt = srcStartPnt
                    snappoint_err = False
                    # print(stPntDestPnt)  #move line -- x- x/+- buffer and y- +- buffer
                    if featCount > 1:
                        print("0")
                        if featCount > 2:
                            # print("1")
                            for intsectFeat in intersectFeats:
                                # print("2")
                                new_seg1 = []
                                new_seg2 = []
                                if intsectFeat.id() != fid:
                                    print("3")
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                        # print("destLnGeom ",destLnGeom)
                                    destStartPnt = destLnGeom[0]
                                    # print("0 destStartPnt",destStartPnt)
                                    destEndPnt = destLnGeom[-1]
                                    destStartBndBox = self.getPntBndbx(destStartPnt)
                                    destEndBndBox = self.getPntBndbx(destEndPnt)
                                    # print(destEndBndBox)
                                    if (srcStartPnt1.intersects(destEndBndBox)):
                                        snappoint_err = True
                                        if (destEndPnt.x() != srcStartPnt.x() or destEndPnt.y() != srcStartPnt.y()):
                                            stDestEndPntNotMatched.append(intsectFeat)
                                            if destEndPnt in stPntDestMatched:
                                                stPntCnter += 1
                                                stPntDestPnt = destEndPnt
                                            else:
                                                stPntDestMatched.append(destEndPnt)

                                        elif (
                                                destEndPnt.x() == srcStartPnt.x() and destEndPnt.y() == srcStartPnt.y()):
                                            stPntMatched.append(intsectFeat)

                                    if (srcStartPnt1.intersects(destStartBndBox)):
                                        snappoint_err = True
                                        if (
                                                destStartPnt.x() != srcStartPnt.x() or destStartPnt.y() != srcStartPnt.y()):
                                            enDestStPntNotMatched.append(intsectFeat)
                                            if destStartPnt in stPntDestMatched:
                                                stPntCnter += 1
                                                stPntDestPnt = destStartPnt
                                            else:
                                                stPntDestMatched.append(destStartPnt)

                                        elif (
                                                destStartPnt.x() == srcStartPnt.x() and destStartPnt.y() == srcStartPnt.y()):
                                            stPntMatched.append(intsectFeat)

                                    if snappoint_err == False:
                                        if intsectFeat.geometry().intersects(bndBox):
                                            # Get the vertices of the feature's geometry that are inside the bounding box
                                            vertices = [
                                                QgsGeometry.asPoint(QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y())))
                                                for v in intsectFeat.geometry().vertices() if bndBox.contains(
                                                    QgsGeometry.asPoint(
                                                        QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))))]
                                            vertices = list(vertices)
                                            if len(vertices) > 0:
                                                vertex_point = random.choice(vertices)
                                                temp_seg = [QgsGeometry.asPoint(
                                                    QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))) for v in
                                                            intsectFeat.geometry().vertices()]
                                                ind_vertex_point = temp_seg.index(vertex_point)
                                                new_seg1 = temp_seg[:ind_vertex_point + 1]
                                                new_seg2 = temp_seg[ind_vertex_point:]
                                                newline1 = QgsGeometry.fromMultiPolylineXY(
                                                    [new_seg1])  # Convert list of Points in a Polyline
                                                newline2 = QgsGeometry.fromMultiPolylineXY([new_seg2])
                                                newline_seg = QgsFeature(intsectFeat)
                                                newline_seg.setGeometry(newline2)
                                                intsectFeat.setGeometry(newline1)
                                                lyr.startEditing()
                                                lyr.updateFeature(intsectFeat)
                                                lyr.addFeature(newline_seg)
                                                fet_change = True
                                                if intsectFeat.geometry().isMultipart():
                                                    fet_geom1 = intsectFeat.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom1 = intsectFeat.geometry().asPolyline()
                                                if newline_seg.geometry().isMultipart():
                                                    fet_geom2 = newline_seg.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom2 = newline_seg.geometry().asPolyline()
                                                fet_geom1[-1] = srcLnGeom[0]
                                                fet_geom2[0] = srcLnGeom[0]
                                                lyr.changeGeometry(intsectFeat.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom1))
                                                lyr.changeGeometry(newline_seg.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom2))
                                                dctErrPnts[intsectFeat.id()] = [srcLnGeom[0], lyr.name()]
                                                dctErrPnts[newline_seg.id()] = [srcLnGeom[0], lyr.name()]

                        else:
                            for intsectFeat in intersectFeats:
                                new_seg1 = []
                                new_seg2 = []
                                if intsectFeat.id() != fid:
                                    print("00")
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                    # print("destLnGeom",destLnGeom)
                                    destStartPnt = destLnGeom[0]
                                    destEndPnt = destLnGeom[-1]
                                    # print("00 destStartPnt",destStartPnt) # get front line point
                                    # print("00 destEndPnt",destEndPnt) # get front line point
                                    # print("srcStartPnt",srcStartPnt) # get front line point
                                    destStartBndBox = self.getPntBndbx(destStartPnt)
                                    destEndBndBox = self.getPntBndbx(destEndPnt)
                                    # print("destStartBndBox",destEndBndBox)  # get rectangle point
                                    # print("destEndBndBox ",destStartBndBox)  # get rectangle point
                                    if (srcStartPnt1.intersects(destEndBndBox)):
                                        snappoint_err = True
                                        if (destEndPnt.x() != srcStartPnt.x() or destEndPnt.y() != srcStartPnt.y()):
                                            stDestEndPntNotMatched.append(intsectFeat)
                                        elif (
                                                destEndPnt.x() == srcStartPnt.x() and destEndPnt.y() == srcStartPnt.y()):
                                            stPntMatched.append(intsectFeat)
                                    if (srcStartPnt1.intersects(destStartBndBox)):
                                        snappoint_err = True
                                        if (
                                                destStartPnt.x() != srcStartPnt.x() or destStartPnt.y() != srcStartPnt.y()):
                                            enDestStPntNotMatched.append(intsectFeat)
                                        elif (
                                                destStartPnt.x() == srcStartPnt.x() and destStartPnt.y() == srcStartPnt.y()):
                                            stPntMatched.append(intsectFeat)
                                    # print(stDestEndPntNotMatched) # empti list 
                                    # print(stPntMatched)   # empti list 
                                    # print(enDestStPntNotMatched)  # empti list 

                                    # Condition 4
                                    if len(stPntMatched) == 0 and len(stDestEndPntNotMatched) == 0 and len(
                                            enDestStPntNotMatched) == 0:
                                        intsectFeat_ = lyr.getFeature(intsectFeat.id())
                                        # print(intsectFeat_)  #get address
                                        geom = intsectFeat_.geometry()
                                         
                                        nearDist, queryPnt, aftVtx, segDirect = geom.closestSegmentWithContext(
                                            srcStartPnt)
                                        # print(nearDist)
                                        # print(queryPnt) # get move line point with nearst front line
                                        # print(aftVtx)
                                        # print(segDirect)
                                        if queryPnt:
                                            geom.insertVertex(queryPnt.x(), queryPnt.y(), aftVtx)
                                            # print(geom.insertVertex(queryPnt.x(), queryPnt.y(), aftVtx)) #get true 
                                            lyr.changeGeometry(intsectFeat_.id(), geom)
                                            # print(lyr.changeGeometry(intsectFeat_.id(), geom))  #get true
                                            # srcLnGeom1=[]
                                            srcLnGeom[0] = queryPnt
                                        lyr.changeGeometry(fid, QgsGeometry().fromPolylineXY(srcLnGeom))
                                        print("Condition 4 f")
                                        lyr.splitFeatures([queryPnt])
                                        dctErrPnts[intsectFeat_.id()] = [srcStartPnt, lyr.name()]
                                            # print("srcEndPnt",srcEndPnt)
                                    if snappoint_err == False:
                                        if intsectFeat.geometry().intersects(bndBox):
                                            # Get the vertices of the feature's geometry that are inside the bounding box
                                            vertices = [
                                                QgsGeometry.asPoint(QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y())))
                                                for v in intsectFeat.geometry().vertices() if bndBox.contains(
                                                    QgsGeometry.asPoint(
                                                        QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))))]
                                            vertices = list(vertices)
                                            if len(vertices) > 0:
                                                vertex_point = random.choice(vertices)
                                                temp_seg = [QgsGeometry.asPoint(
                                                    QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))) for v in
                                                            intsectFeat.geometry().vertices()]
                                                ind_vertex_point = temp_seg.index(vertex_point)
                                                new_seg1 = temp_seg[:ind_vertex_point + 1]
                                                new_seg2 = temp_seg[ind_vertex_point:]
                                                newline1 = QgsGeometry.fromMultiPolylineXY(
                                                    [new_seg1])  # Convert list of Points in a Polyline
                                                newline2 = QgsGeometry.fromMultiPolylineXY([new_seg2])
                                                newline_seg = QgsFeature(intsectFeat)
                                                newline_seg.setGeometry(newline2)
                                                intsectFeat.setGeometry(newline1)
                                                lyr.startEditing()
                                                lyr.updateFeature(intsectFeat)
                                                lyr.addFeature(newline_seg)
                                                fet_change = True
                                                if intsectFeat.geometry().isMultipart():
                                                    fet_geom1 = intsectFeat.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom1 = intsectFeat.geometry().asPolyline()
                                                if newline_seg.geometry().isMultipart():
                                                    fet_geom2 = newline_seg.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom2 = newline_seg.geometry().asPolyline()
                                                fet_geom1[-1] = srcLnGeom[0]
                                                fet_geom2[0] = srcLnGeom[0]
                                                lyr.changeGeometry(intsectFeat.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom1))
                                                lyr.changeGeometry(newline_seg.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom2))
                                                dctErrPnts[intsectFeat.id()] = [srcLnGeom[0], lyr.name()]
                                                dctErrPnts[newline_seg.id()] = [srcLnGeom[0], lyr.name()]
                  
                        #     # Condition 1
                        if len(stPntMatched) > 0:
                                pass
                                if len(stDestEndPntNotMatched) > 0:
                                    print("Condition 1-1") 
                                    for intsectFeat_ in stDestEndPntNotMatched:
                                        intsectFeat = lyr.getFeature(intsectFeat_.id())
                                        if intsectFeat.geometry().isMultipart():
                                            destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                        else:
                                            destLnGeom = intsectFeat.geometry().asPolyline()
                                        # print(destLnGeom[-1])
                                        destLnGeom[-1] = srcStartPnt
                                        # print("destLnGeom[-1]",destLnGeom[-1]) 
                                        lyr.changeGeometry(intsectFeat.id(), QgsGeometry().fromPolylineXY(destLnGeom))
                                        print("Condition 1") 
                                        lyr.splitFeatures([srcStartPnt])
                                        dctErrPnts[intsectFeat.id()] = [srcStartPnt, lyr.name()]
                                if len(enDestStPntNotMatched) >0:
                                    for intsectFeat_ in enDestStPntNotMatched:
                                        intsectFeat = lyr.getFeature(intsectFeat_.id())
                                        if intsectFeat.geometry().isMultipart():
                                            destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                        else:
                                            destLnGeom = intsectFeat.geometry().asPolyline()
                                        destLnGeom[0] = srcStartPnt
                                        # print(destLnGeom[0]) #get move point 
                                        lyr.changeGeometry(intsectFeat.id(), QgsGeometry().fromPolylineXY(destLnGeom))
                                        print("Condition 1-2") 
                                        lyr.splitFeatures([srcStartPnt])
                                        dctErrPnts[intsectFeat.id()] = [srcStartPnt, lyr.name()]
                        else:
                            # Condition 2
                                if stPntCnter > 0:
                                    srcLnGeom[0] = stPntDestPnt
                                    # print(destLnGeom[0]) # get move point 
                                    lyr.changeGeometry(fid, QgsGeometry().fromPolylineXY(srcLnGeom))
                                    lyr.splitFeatures([stPntDestPnt])
                                    print("Condition 2") 
                                    dctErrPnts[fid] = [stPntDestPnt, lyr.name()]
                                # Condition 3
                                else:
                                    if len(stDestEndPntNotMatched) > 0:
                                         
                                        for intsectFeat_ in stDestEndPntNotMatched:
                                            intsectFeat = lyr.getFeature(intsectFeat_.id())
                                            if intsectFeat.geometry().isMultipart():
                                                destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                            else:
                                                destLnGeom = intsectFeat.geometry().asPolyline()
                                            destLnGeom[-1] = srcStartPnt
                                            lyr.changeGeometry(intsectFeat.id(),QgsGeometry().fromPolylineXY(destLnGeom))
                                            print("Condition 2 1")
                                            lyr.splitFeatures([srcStartPnt])
                                            dctErrPnts[intsectFeat.id()] = [srcStartPnt, lyr.name()]
                                    if len(enDestStPntNotMatched) > 0:
                                        for intsectFeat_ in enDestStPntNotMatched:
                                            intsectFeat = lyr.getFeature(intsectFeat_.id())
                                            if intsectFeat.geometry().isMultipart():
                                                destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                            else:
                                                destLnGeom = intsectFeat.geometry().asPolyline()
                                            destLnGeom[0] = srcStartPnt
                                            lyr.changeGeometry(intsectFeat.id(),
                                                            QgsGeometry().fromPolylineXY(destLnGeom))
                                            lyr.splitFeatures([srcStartPnt])
                                            print("Condition 2 2")
                                            dctErrPnts[intsectFeat.id()] = [srcStartPnt, lyr.name()]

                    bndBox = self.getPntBndbx(srcEndPnt)
                    intersectFeats, featCount = self.getIntersectFeats(lyr, bndBox)
                    # print(intersectFeats)  # get adresss
                    # print(featCount) # get select feat count
                    lyr.removeSelection()
                    stPntMatched = []
                    endPntMatched = []
                    stDestEndPntNotMatched = []
                    enDestStPntNotMatched = []
                    stPntCnter = 0
                    stPntDestMatched = []
                    stPntDestPnt = srcEndPnt
                    snappoint_err = False
                    # print(srcEndPnt)# get move line point orignle
                    if featCount > 1:
                        if featCount > 2:
                            for intsectFeat in intersectFeats:
                                new_seg1 = []
                                new_seg2 = []
                                if intsectFeat.id() != fid:
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                        # print(destLnGeom) # not run
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                        # print(destLnGeom) # not run
                                    # print(destLnGeom) # not run
                                    destStartPnt = destLnGeom[0]
                                    destEndPnt = destLnGeom[-1]
                                    destStartBndBox = self.getPntBndbx(destStartPnt)
                                    destEndBndBox = self.getPntBndbx(destEndPnt)
                                    if (srcEndPnt1.intersects(destEndBndBox)):
                                        snappoint_err = True
                                        if (destEndPnt.x() != srcEndPnt.x() or destEndPnt.y() != srcEndPnt.y()):
                                            stDestEndPntNotMatched.append(intsectFeat)
                                            if destEndPnt in stPntDestMatched:
                                                stPntCnter += 1
                                                stPntDestPnt = destEndPnt
                                            else:
                                                stPntDestMatched.append(destEndPnt)

                                        elif (destEndPnt.x() == srcEndPnt.x() and destEndPnt.y() == srcEndPnt.y()):
                                            stPntMatched.append(intsectFeat)

                                    if (srcEndPnt1.intersects(destStartBndBox)):
                                        snappoint_err = True
                                        if (destStartPnt.x() != srcEndPnt.x() or destStartPnt.y() != srcEndPnt.y()):
                                            enDestStPntNotMatched.append(intsectFeat)
                                            if destStartPnt in stPntDestMatched:
                                                stPntCnter += 1
                                                stPntDestPnt = destStartPnt
                                            else:
                                                stPntDestMatched.append(destStartPnt)

                                        elif (
                                                destStartPnt.x() == srcEndPnt.x() and destStartPnt.y() == srcEndPnt.y()):
                                            stPntMatched.append(intsectFeat)
                                    if snappoint_err == False:
                                        if intsectFeat.geometry().intersects(bndBox):
                                            # Get the vertices of the feature's geometry that are inside the bounding box
                                            vertices = [
                                                QgsGeometry.asPoint(QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y())))
                                                for v in intsectFeat.geometry().vertices() if bndBox.contains(
                                                    QgsGeometry.asPoint(
                                                        QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))))]
                                            vertices = list(vertices)
                                            if len(vertices) > 0:
                                                vertex_point = random.choice(vertices)
                                                temp_seg = [QgsGeometry.asPoint(
                                                    QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))) for v in
                                                            intsectFeat.geometry().vertices()]
                                                ind_vertex_point = temp_seg.index(vertex_point)
                                                new_seg1 = temp_seg[:ind_vertex_point + 1]
                                                new_seg2 = temp_seg[ind_vertex_point:]
                                                newline1 = QgsGeometry.fromMultiPolylineXY(
                                                    [new_seg1])  # Convert list of Points in a Polyline
                                                newline2 = QgsGeometry.fromMultiPolylineXY([new_seg2])
                                                newline_seg = QgsFeature(intsectFeat)
                                                newline_seg.setGeometry(newline2)
                                                intsectFeat.setGeometry(newline1)
                                                lyr.startEditing()
                                                lyr.updateFeature(intsectFeat)
                                                lyr.addFeature(newline_seg)
                                                fet_change = True
                                                if intsectFeat.geometry().isMultipart():
                                                    fet_geom1 = intsectFeat.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom1 = intsectFeat.geometry().asPolyline()
                                                if newline_seg.geometry().isMultipart():
                                                    fet_geom2 = newline_seg.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom2 = newline_seg.geometry().asPolyline()
                                                fet_geom1[-1] = srcLnGeom[-1]
                                                fet_geom2[0] = srcLnGeom[-1]
                                                lyr.changeGeometry(intsectFeat.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom1))
                                                lyr.changeGeometry(newline_seg.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom2))
                                                dctErrPnts[intsectFeat.id()] = [srcLnGeom[-1], lyr.name()]
                                                dctErrPnts[newline_seg.id()] = [srcLnGeom[-1], lyr.name()]


                        else:
                            for intsectFeat in intersectFeats:
                                new_seg1 = []
                                new_seg2 = []
                                if intsectFeat.id() != fid:
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                    destStartPnt = destLnGeom[0]
                                    destEndPnt = destLnGeom[-1]
                                    # print(destStartPnt) # not run 
                                    destStartBndBox = self.getPntBndbx(destStartPnt)
                                    destEndBndBox = self.getPntBndbx(destEndPnt)
                                    if (srcEndPnt1.intersects(destEndBndBox)):
                                        snappoint_err = True
                                        if (destEndPnt.x() != srcEndPnt.x() or destEndPnt.y() != srcEndPnt.y()):
                                            stDestEndPntNotMatched.append(intsectFeat)
                                        elif (destEndPnt.x() == srcEndPnt.x() and destEndPnt.y() == srcEndPnt.y()):
                                            stPntMatched.append(intsectFeat)
                                    if (srcEndPnt1.intersects(destStartBndBox)):
                                        snappoint_err = True
                                        if (destStartPnt.x() != srcEndPnt.x() or destStartPnt.y() != srcEndPnt.y()):
                                            enDestStPntNotMatched.append(intsectFeat)
                                        elif (
                                                destStartPnt.x() == srcEndPnt.x() and destStartPnt.y() == srcEndPnt.y()):
                                            stPntMatched.append(intsectFeat)
                                    
                                    # print(stDestEndPntNotMatched) # empti list  dont run
                                    # print(stPntMatched)   # empti list 
                                    # print(enDestStPntNotMatched)  # empti list 

                                    ##Condition 4
                                    #if snappoint_err == True:
                                    if len(stPntMatched) == 0 and len(stDestEndPntNotMatched) == 0 and len(
                                            enDestStPntNotMatched) == 0:
                                        intsectFeat_ = lyr.getFeature(intsectFeat.id())
                                        geom = intsectFeat_.geometry()
                                        nearDist, queryPnt, aftVtx, segDirect = geom.closestSegmentWithContext(
                                            srcEndPnt)
                                        if queryPnt:
                                            geom.insertVertex(queryPnt.x(), queryPnt.y(), aftVtx)
                                            lyr.changeGeometry(intsectFeat_.id(), geom)
                                            srcLnGeom[-1] = queryPnt
                                            # print(" queryPnt", queryPnt)
                                        lyr.changeGeometry(fid, QgsGeometry().fromPolylineXY(srcLnGeom))
                                        lyr.splitFeatures([queryPnt])
                                        dctErrPnts[intsectFeat_.id()] = [srcEndPnt, lyr.name()]
                                        print("Condition 4")
                                        # print("srcEndPnt",srcEndPnt)
                                    if snappoint_err == False:
                                        if intsectFeat.geometry().intersects(bndBox):
                                            # Get the vertices of the feature's geometry that are inside the bounding box
                                            vertices = [
                                                QgsGeometry.asPoint(QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y())))
                                                for v in intsectFeat.geometry().vertices() if bndBox.contains(
                                                    QgsGeometry.asPoint(
                                                        QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))))]
                                            vertices = list(vertices)
                                            if len(vertices) > 0:
                                                vertex_point = random.choice(vertices)
                                                temp_seg = [QgsGeometry.asPoint(
                                                    QgsGeometry.fromPointXY(QgsPointXY(v.x(), v.y()))) for v in
                                                            intsectFeat.geometry().vertices()]
                                                ind_vertex_point = temp_seg.index(vertex_point)
                                                new_seg1 = temp_seg[:ind_vertex_point + 1]
                                                new_seg2 = temp_seg[ind_vertex_point:]
                                                newline1 = QgsGeometry.fromMultiPolylineXY(
                                                    [new_seg1])  # Convert list of Points in a Polyline
                                                newline2 = QgsGeometry.fromMultiPolylineXY([new_seg2])
                                                newline_seg = QgsFeature(intsectFeat)
                                                newline_seg.setGeometry(newline2)
                                                intsectFeat.setGeometry(newline1)
                                                lyr.startEditing()
                                                lyr.updateFeature(intsectFeat)
                                                lyr.addFeature(newline_seg)
                                                fet_change = True
                                                if intsectFeat.geometry().isMultipart():
                                                    fet_geom1 = intsectFeat.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom1 = intsectFeat.geometry().asPolyline()
                                                if newline_seg.geometry().isMultipart():
                                                    fet_geom2 = newline_seg.geometry().asMultiPolyline()[0]
                                                else:
                                                    fet_geom2 = newline_seg.geometry().asPolyline()
                                                fet_geom1[-1] = srcLnGeom[-1]
                                                fet_geom2[0] = srcLnGeom[-1]
                                                lyr.changeGeometry(intsectFeat.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom1))
                                                lyr.changeGeometry(newline_seg.id(),
                                                                   QgsGeometry().fromPolylineXY(fet_geom2))
                                                dctErrPnts[intsectFeat.id()] = [srcLnGeom[-1], lyr.name()]
                                                dctErrPnts[newline_seg.id()] = [srcLnGeom[-1], lyr.name()]

                        # #Condition 1
                        if len(stPntMatched) > 0:
                            if len(stDestEndPntNotMatched) > 0:
                                for intsectFeat_ in stDestEndPntNotMatched:
                                    intsectFeat = lyr.getFeature(intsectFeat_.id())
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                    destLnGeom[-1] = srcEndPnt
                                    lyr.changeGeometry(intsectFeat.id(), QgsGeometry().fromPolylineXY(destLnGeom))
                                    lyr.splitFeatures([srcEndPnt])
                                    dctErrPnts[intsectFeat.id()] = [srcEndPnt, lyr.name()]
                                    print("Condition 1")
                            if len(enDestStPntNotMatched) > 0:
                                for intsectFeat_ in enDestStPntNotMatched:
                                    intsectFeat = lyr.getFeature(intsectFeat_.id())
                                    if intsectFeat.geometry().isMultipart():
                                        destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                    else:
                                        destLnGeom = intsectFeat.geometry().asPolyline()
                                    destLnGeom[0] = srcEndPnt
                                    lyr.changeGeometry(intsectFeat.id(), QgsGeometry().fromPolylineXY(destLnGeom))
                                    lyr.splitFeatures([srcEndPnt])
                                    dctErrPnts[intsectFeat.id()] = [srcEndPnt, lyr.name()]
                                    print("Condition 1  1")
                        else:
                            # Condition 2
                            if stPntCnter > 0:
                                srcLnGeom[-1] = stPntDestPnt
                                lyr.changeGeometry(fid, QgsGeometry().fromPolylineXY(srcLnGeom))
                                lyr.splitFeatures([stPntDestPnt])
                                print("Condition 2")
                                dctErrPnts[fid] = [stPntDestPnt, lyr.name()]
                            # Condition 3
                            else:
                                if len(stDestEndPntNotMatched) > 0:
                                    for intsectFeat_ in stDestEndPntNotMatched:
                                        intsectFeat = lyr.getFeature(intsectFeat_.id())
                                        if intsectFeat.geometry().isMultipart():
                                            destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                        else:
                                            destLnGeom = intsectFeat.geometry().asPolyline()
                                        destLnGeom[-1] = srcEndPnt
                                        lyr.changeGeometry(intsectFeat.id(),
                                                           QgsGeometry().fromPolylineXY(destLnGeom))
                                        lyr.splitFeatures([srcEndPnt])
                                        dctErrPnts[intsectFeat.id()] = [srcEndPnt, lyr.name()]
                                        print("Condition 3")
                                if len(enDestStPntNotMatched) > 0:
                                    for intsectFeat_ in enDestStPntNotMatched:
                                        intsectFeat = lyr.getFeature(intsectFeat_.id())
                                        if intsectFeat.geometry().isMultipart():
                                            destLnGeom = intsectFeat.geometry().asMultiPolyline()[0]
                                        else:
                                            destLnGeom = intsectFeat.geometry().asPolyline()
                                        destLnGeom[0] = srcEndPnt
                                        lyr.changeGeometry(intsectFeat.id(),
                                                           QgsGeometry().fromPolylineXY(destLnGeom))
                                        lyr.splitFeatures([srcEndPnt])
                                        dctErrPnts[intsectFeat.id()] = [srcEndPnt, lyr.name()]
                                        # print("Condition 3  1")
                                        


                        # break
            # break
            # lyr.commitChanges()
            self.iface.messageBar().pushMessage("Dangle Error",
                                                "Snapping for " + str(lyr.name()) + " layer is completed with self")
            QgsMessageLog.logMessage(
                "Dangle Error : Snapping for " + str(lyr.name()) + " layer is completed with self", "Dangle Error",
                Qgis.Info)

            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids, feats[1]], feats[0])

            if len(dctErrPnts) > 0:
                QgsProject.instance().addMapLayer(vMemorylayer)
                layerData.addFeatures(self.errorPointFeatures)
                vMemorylayer.commitChanges()
                QMessageBox.information(None, 'Dangle Error', 'Process completed. Error layer added')
            else:
                QMessageBox.information(None, 'Dangle Error', 'Process completed. No error found')
            self.srcLnLayer.startEditing()
        except Exception as e:
            self.srcLnLayer.startEditing()
            QgsMessageLog.logMessage("[Error :]" + str(e), "Dangle Error", Qgis.Info)
            QMessageBox.critical(None, "Error ", str(e))

    # except Exception as e:
    #     QgsMessageLog.logMessage("[Error :]" +str(e), "Dangle Error", Qgis.Info)

    def getRefLineFeatures(self):
        self.canvasLayers = self.iface.mapCanvas().layers()
        # print(self.canvasLayers)
        for lyr in self.canvasLayers:
            if lyr.type() == 0:
                if self.srcLnLayer.name() != lyr.name() and lyr.geometryType()== 1:
                    if lyr not in self.refFeatdict:
                        self.refFeatdict[lyr] = []
                    for feat in lyr.getFeatures():
                        if feat.geometry():
                            self.refFeatdict[lyr].append(feat)
    def getSrcLineFeatures(self):
        num = 0
        if self.srcLnLayer.name() == "" or self.srcLnLayer is None:
            QMessageBox.critical(None, "Source Layer Error", "Fetch WorkArea Allocation to get source output polyline layer.")
            return
        if self.srcLnLayer.selectedFeatureCount() > 0:
            num += self.srcLnLayer.selectedFeatureCount()
            self.srcFeatdict[self.srcLnLayer] = self.srcLnLayer.selectedFeatures()
            self.iface.messageBar().pushMessage("Dangle Error", "Running over selected features of "+str(self.srcLnLayer.name())+" layer")
            QgsMessageLog.logMessage("Dangle Error : Running over selected features of " +str(self.srcLnLayer.name())+" layer", "Dangle Error", Qgis.Info)
        # else:
            # self.iface.messageBar().pushMessage("Dangle Error", "Running over entire features of "+str(self.srcLnLayer.name())+" layer")
            # QgsMessageLog.logMessage("Dangle Error : Running over entire features of " +str(self.srcLnLayer.name())+" layer", "Dangle Error", Qgis.Info)
            # if self.srcLnLayer not in self.srcFeatdict:
                # self.srcFeatdict[self.srcLnLayer] = []
            # for feat in self.srcLnLayer.getFeatures():
                # num += 1
                # if feat.geometry():
                    # self.srcFeatdict[self.srcLnLayer].append(feat)
            # print(num)
        return num
    def getIntersectFeats(self, lyr, bndBox):
        intersectFeats = lyr.getFeatures(QgsFeatureRequest().setFilterRect(bndBox))
        lyr.selectByRect(bndBox)
        # print(bndBox)
        return intersectFeats, lyr.selectedFeatureCount()
    def getPntBndbx(self, pnt):
        # print("buffer",self.buffer)
        r = self.buffer
        # p = geom.asPoint() 
        p = pnt
        # print("p",p)  # get point of move line and frount line 
        pointBndBox = QgsRectangle(p.x()-r,p.y()-r,p.x()+r,p.y()+r)
        # print(pointBndBox)  #get point +- and return
        return pointBndBox
    def updateErrorPointFeatures(self, attrList, pntXY):
        # print("pntXy",pntXY)
        newfeat = QgsFeature()
        newfeat.setAttributes(attrList)
        newfeat.setGeometry(QgsGeometry.fromPointXY(pntXY))
        self.errorPointFeatures.append(newfeat)
        
    def split (self, pnt):
            vertex_list=pnt
            for feature in vertex_list:
                geom=feature.geometry()
                vertex_list=geom.asMultiPolyline()[0]
                if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                    vertex_list=geom.asMultiPolyline()[0]
                else:
                    vertex_list=geom.asPolyline()
            # print(" vertex_list",  vertex_list)
                Fst_last_vertex=[]
                a=vertex_list[0]
                Fst_last_vertex.append(a)
                b=vertex_list[-1]
                Fst_last_vertex.append(b)
                print("Fst_last_vertex",Fst_last_vertex)

                # value = 1
                # # print(value)
                # if str(self.input_layer.crs().authid()) == 'EPSG:4326':
                #     d = QgsDistanceArea()
                #     d.setSourceCrs(self.input_layer.crs(), QgsProject.instance().transformContext())
                #     d.setEllipsoid(QgsProject.instance().ellipsoid())
                #     self.buffer2 = d.convertLengthMeasurement(value, 6)
                #     # print("self buffer", self.buffer1)
                # else: 
                #     self.buffer2 = value
                    # print(value)
            
                for vertex in  Fst_last_vertex:
                    # self.input_layer.splitFeatures([vertex])
                    # return vertex
                        print("vertex",vertex)
                        point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
                        # print("point_geom",point_geom)
                        self.buffer=point_geom.buffer(self.buffer2,6)
                        # print("self.buffer",self.buffer)
                        bbox=self.buffer.boundingBox()
                        intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
                        # print("intersectFeats",intersectFeats)
                        geom_list2=[]
                        for feat in intersectFeats:
                            # point_geom = QgsGeometry.fromPointXY(QgsPointXY(feat))
                            # print("point_geom",point_geom)
                            # print("feat.id()",feat)
                            # print("feature.id()",feature.id())
                            if feat.id()!=feature.id():
                                # print("geom_list2")
                                if feature.geometry().intersects(feat.geometry()):
                                    # self.input_layer.splitFeatures()
                                    print("one line")
                                    geom_list2.append(feat)
                            print("geom_list 2",geom_list2)

                            # Distance between two features in the same layer
                        

                            # name="Intersect error"
                            if len(geom_list2)<=1:
                                nearDist, queryPnt, aftVtx, segDirect = geom.closestSegmentWithContext(vertex)
                                print("queryPnt",queryPnt)
                                pass
                                self.input_layer.splitFeatures([queryPnt])
                                print("one line")



        #  vertex=pnt
        #  for vertex in vertex:
        #                 print("vertex",vertex)
        #                 point_geom= QgsGeometry.fromPointXY(QgsPointXY(vertex))
        #                 # print("point_geom",point_geom)
        #                 self.buffer=point_geom.buffer(self.buffer2,6)
        #                 # print("self.buffer",self.buffer)
        #                 bbox=self.buffer.boundingBox()
        #                 intersectFeats = [f for f in self.input_layer.getFeatures(QgsFeatureRequest(bbox))]
        #                 # print("intersectFeats",intersectFeats)
        #                 geom_list2=[]
        #                 for feat in intersectFeats:
        #                     # point_geom = QgsGeometry.fromPointXY(QgsPointXY(feat))
        #                     # print("point_geom",point_geom)
        #                     # print("feat.id()",feat)
        #                     # print("feature.id()",feature.id())
        #                     if feat.id()!=feature.id():
        #                         # print("geom_list2")
        #                         if feature.geometry().intersects(feat.geometry()):
        #                             # self.input_layer.splitFeatures()
        #                             print("one line")
        #                             geom_list2.append(feat)
        #                     print("geom_list 2",geom_list2)

        #                     # Distance between two features in the same layer
                        

        #                     # name="Intersect error"
        #                     if len(geom_list2)<=1:
        #                         nearDist, queryPnt, aftVtx, segDirect = geom.closestSegmentWithContext(vertex)
        #                         print("queryPnt",queryPnt)
        #                         pass
        #                         self.input_layer.splitFeatures([vertex])
        #                         print("one line")