# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LineGeometryReshapeTool
                                 A QGIS plugin
 this ool used to sharp line/edge converted to smooth curve
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by genesys
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from qgis.gui import *
from qgis.core import *
from shapely import affinity
from shapely.wkt import dumps, loads
from shapely.geometry import *
import qgis
import  math
import itertools
from PyQt5.QtWidgets import *



# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .line_geometry_reshape_tool_dialog import LineGeometryReshapeToolDialog
import os.path


class LineGeometryReshapeTool(QgsMapToolEmitPoint):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        QgsMapToolEmitPoint.__init__(self, self.iface.mapCanvas())
        self.layer = None
        self.m = None
        self.snapp = None
        self.dragging = False
        self.snapIndicator = None
        self.rubber = None
        self.started = False
        self.coords = []
        self.canvas = self.iface.mapCanvas()
        # self.snapper = QgsMapCanvasSnapper(self.canvas)
        self.snapper = self.canvas.snappingUtils()
        self.autoCursor = QCursor(QPixmap(["16 16 3 1",
                                           "      c None",
                                           ".     c #FF00FF",
                                           "+     c #FFFFFF",
                                           "                ",
                                           "       +.+      ",
                                           "      ++.++     ",
                                           "     +.....+    ",
                                           "    +.     .+   ",
                                           "   +.   .   .+  ",
                                           "  +.    .    .+ ",
                                           " ++.    .    .++",
                                           " ... ...+... ...",
                                           " ++.    .    .++",
                                           "  +.    .    .+ ",
                                           "   +.   .   .+  ",
                                           "   ++.     .+   ",
                                           "    ++.....+    ",
                                           "      ++.++     ",
                                           "       +.+      "]))
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.setCursor(self.autoCursor)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LineGeometryReshapeTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Line Geometry Reshape Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LineGeometryReshapeTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None, 
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

       
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        action.setCheckable(True)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/line_geometry_reshape_tool/icon.png'
        self.iconAction=self.add_action(
            icon_path,
            text=self.tr(u'Line Geometry Reshape Tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Line Geometry Reshape Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        if self.first_start == True:
            self.first_start = False
            self.dlg = LineGeometryReshapeToolDialog()
            self.dlg.ok.clicked.connect(self.set_valuve)
            self.dlg.ok.clicked.connect(self.snap)
            # self.dlg.ok.clicked.connect(self.run_)
            self.dlg.ok.clicked.connect(self.close)
            self.dlg.cancel.clicked.connect(self.close)


        # show the dialog
        self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        # self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg.show()
        
        # self.addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            self.close()
            pass
        lay = self.iface.activeLayer()
        fc = lay.selectedFeatureCount()
        # fc = lay.getFeatureCount()
        # fc = lay.featureCount()
        # print("FC", fc)

        if fc<=1:
            try:

                    lay = self.iface.activeLayer()
                    if lay.geometryType() == 1:
                        pass
            except:
                    pass

            if self.iconAction.isChecked():
                    self.arc = None
                    self.draggable = False
                    if self.iface.activeLayer() == None:
                        self.iface.messageBar().pushInfo("No Active Layer:", "Layer is not Selected")
                        self.iconAction.setChecked(False)
                        return
                    self.layer = self.iface.activeLayer()
                    if self.layer:
                        # self.iface.mapCanvas().mapToolSet.connect(self.mapToolChanged)
                        if self.layer.geometryType() != 1:
                            self.iface.messageBar().pushInfo("ADD POLYGON:", "Please select the Polygon Layer ")
                            self.iconAction.trigger()
                            return
                    else:
                        self.iconAction.trigger()
                    self.iface.mapCanvas().setMapTool(self)
                    self.count = 0
                    # print "Hi"
                    pass
            else:
                    # self.iface.mapCanvas().mapToolSet.disconnect()
                    self.iface.mapCanvas().unsetMapTool(self)
                   
        else:
                self.iface.messageBar().pushMessage("Error", "Please select single feature", level=Qgis.Critical,duration=3)

    # def run_(self):
    #     lay = self.iface.activeLayer()
    #     fc = lay.selectedFeatureCount()
    #     # fc = lay.featureCount()
    #     # print("FC", fc)

    #     if fc<=1:
    #         try:

    #                 lay = self.iface.activeLayer()
    #                 if lay.geometryType() == 1:
    #                     pass
    #         except:
    #                 pass

    #         if self.iconAction.isChecked():
    #                 self.arc = None
    #                 self.draggable = False
    #                 if self.iface.activeLayer() == None:
    #                     self.iface.messageBar().pushInfo("No Active Layer:", "Layer is not Selected")
    #                     self.iconAction.setChecked(False)
    #                     return
    #                 self.layer = self.iface.activeLayer()
    #                 if self.layer:
    #                     # self.iface.mapCanvas().mapToolSet.connect(self.mapToolChanged)
    #                     if self.layer.geometryType() != 1:
    #                         self.iface.messageBar().pushInfo("ADD POLYGON:", "Please select the Polygon Layer ")
    #                         self.iconAction.trigger()
    #                         return
    #                 else:
    #                     self.iconAction.trigger()
    #                 self.iface.mapCanvas().setMapTool(self)
    #                 self.count = 0
    #                 # print "Hi"
    #                 pass
    #         else:
    #                 # self.iface.mapCanvas().mapToolSet.disconnect()
    #                 self.iface.mapCanvas().unsetMapTool(self)
                   
    #     else:
    #             self.iface.messageBar().pushMessage("Error", "Please select single feature", level=Qgis.Critical,duration=3)
    #             return 
    #     self.dlg.close()
        
    def close(self):
        self.dlg.close()
        return
        


    def getNextId(self,geom,pt):
            # vert_list=[]
            # for feature in self.layer.getFeatures():
            #     for pnt in feature.geometry().asPolyline():
            #         vert_list.append((pnt.x(), pnt.y()))
            # # features = self.layer.getFeatures()
            # # for feature in features:
            # #     geom = feature.geometry()
            # #     print(geom.asPoint().x(), geom.asPoint().y())
            # # vert_list=geom.LineString ()[0]
            # if geom.wkbType() in [QgsWkbTypes.MultilineString]:
            #     vert_list=geom.asMultiPolyline ()[0][0]
            # else:
            #     vert_list=geom.asPolyline()[0]
            if geom.wkbType() in [QgsWkbTypes.MultiLineString ]:
                vert_list=geom.asMultiPolyline()[0]
            else:
                vert_list=geom.asPolyline()
            # vert_list=geom.asPolyline()
            # print(vert_list)
            i=0
            idx=0
            for j in range(len(vert_list) - 1):
                idx += 1
                pt1=vert_list[j]
                pt2=vert_list[j+1]
                poly_segm=QgsGeometry.fromPolylineXY([pt1, pt2])
                point_geom=QgsGeometry.fromPointXY(pt)
                buffer_point=point_geom.buffer(0.000005,5)
                if buffer_point.intersects(poly_segm):
                    # print('text')
                    break

            return idx


    def reshapePolygonByLine(self, geom):
            # self.layer.destroyEditCommand()
            # self.layer.beginEditCommand("Feature added")
            for feature in self.layer.selectedFeatures():
                QgsMessageLog.logMessage('feature id - ' + str(feature.id()), 'AdvanceDigitize_AutoTrace')
                feat_geom = feature.geometry()
                line = QgsLineString([QgsPoint(i) for i in geom.asPolyline()])
                # print('geom.asPolyline()',line)
                reshape_success = feat_geom.reshapeGeometry(line)
                # print('reshape_success',reshape_success)
                if reshape_success == 0:
                    if feat_geom.isEmpty():
                        QMessageBox.information(None, 'Reshape Polygons',
                                                'The feature cannot be reshaped because the resulting geometry is empty')
                        return
                    self.layer.changeGeometry(feature.id(), feat_geom)
                    # self.layer.destroyEditCommand()
                    QgsMessageLog.logMessage('success', 'Reshape Polygons')
                else:
                    QgsMessageLog.logMessage('failure', 'Reshape Polygons')
    def snap (self):
            lay = self.iface.activeLayer()
            lay.startEditing()
            my_snap_config = QgsSnappingConfig()
            my_snap_config.setEnabled(True)
            my_snap_config.setType(QgsSnappingConfig.VertexAndSegment)
            my_snap_config.setUnits(QgsTolerance.Pixels)
            my_snap_config.setTolerance(12)
            my_snap_config.setIntersectionSnapping(True)
            QgsProject.instance().setSnappingConfig(my_snap_config)
    def set_valuve(self):
        if (self.dlg.lineEdit.text()):
            self.valus = float(self.dlg.lineEdit.text())
            lay = self.iface.activeLayer()
            fc = lay.selectedFeatureCount()
            if fc==0:
                QMessageBox.information(self.dlg, "Info",
                                            " Please Select Layer")
        else:
            QMessageBox.information(self.dlg, "Info",
                                            " Please Enter Value")
        


    def canvasPressEvent(self, event):
        #print"canvasPressEvent"
        # print(" event", event)
        self.temp = None
        if event.button() == Qt.LeftButton:
            if self.draggable:
                self.draggable = False
                return
            self.pos = event.pos()
            # print("self.pos", self.pos)

            # mapPt, layerPt = self.transformCoordinates(self.pos)
            # print mapPt
            # (retval, result) = self.snapper.snapToBackgroundLayers(self.pos)
            result = self.snapper.snapToMap(self.pos, None)
            # print("result",result)
            x = event.pos().x()
            y = event.pos().y()
            if result:
                mapPt = result.point()
                # print("mapPt", mapPt)
                self.mappoint=mapPt

            else:
                mapPt = QgsMapToPixel.toMapCoordinates(self.canvas.getCoordinateTransform(), x, y)
                self.mappoint = mapPt
                # print("mapPt", mapPt)
            self.count = self.count + 1
            
            if self.count > 1:
                self.draggable = True
                pt1 = self.coords[self.count - 2]
                x = (pt1.x() + mapPt.x()) / 2
                y = (pt1.y() + mapPt.y()) / 2
                # print("x", x, "y",y)
                self.coords.append(QgsPoint(x, y))
                pass
            self.coords.append(QgsPoint(mapPt.x(), mapPt.y()))
            # print("self.coords",self.coords)
            if len(self.coords) > 1:
                for feature in self.layer.selectedFeatures():
                    feat_geom = feature.geometry()
                    crs = str(self.layer.crs().authid())
                    dscrs=str(QgsProject.instance().crs().authid())
                    sourceCrs = QgsCoordinateReferenceSystem(dscrs)
                    destCrs = QgsCoordinateReferenceSystem(crs)
                    tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())
                    layerPt1= QgsGeometry.fromPointXY(QgsPointXY(self.coords[0]))
                    layerPt1.transform(tr)
                    # print("layerPt1 as point ", layerPt1.asPoint())
                    idx=self.getNextId(feat_geom,QgsPointXY(layerPt1.asPoint())) 
                    # idx=2 
                    # print('idx',idx)
                    feat_geom.insertVertex(layerPt1.asPoint().x(),layerPt1.asPoint().y(), idx)
                    # feat_geom.insertVertex(layerPt1.asPoint().x(),layerPt1.asPoint().y(), 1)
                    layerPt2= QgsGeometry.fromPointXY(QgsPointXY(self.coords[-1]))
                    layerPt2.transform(tr)
                    idx2 = self.getNextId(feat_geom, QgsPointXY(layerPt2.asPoint()))
                    # print('idx2', idx2)
                    # self.layer.changeGeometry(feature.id(), feat_geom)
                    # close2 = min([con_lin.closestSegmentWithContext(QgsPointXY(self.coords[-1]))])
                    feat_geom.insertVertex(layerPt2.asPoint().x(),layerPt2.asPoint().y(),idx2)
                    # feat_geom.insertVertex(layerPt2.asPoint().x(),layerPt2.asPoint().y(),3)
                    self.layer.changeGeometry(feature.id(), feat_geom)
                    self.dlg.close()
                    # # print('poly',feat_geom.asMultiPolygon())


                # print len(self.coords)
                if self.rubber == None:
                    self.num = 0
                    self.pts = []
                    self.rubber = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.LineGeometry)
                    self.rubber.setFillColor(QColor("Red"))
                    # self.rubber.setStrokeColor(QColor("Red"))
                    # self.rubber.setBorderColor(QColor("Red"))
                    self.rubber.setColor(QColor("Red"))
                    self.rubber.setBrushStyle(Qt.NoBrush)
                    self.rubber.setWidth(3)
                    self.rubber.setLineStyle(Qt.DotLine)
                    self.dragging = True
                if self.arc == None:
                    self.arc = QgsCircularString()
                    pass
                self.rubber.reset()
                # print("self.coords",self.coords)
                self.arc.setPoints(self.coords)
                geom = QgsGeometry.fromWkt(self.arc.asWkt())
                self.points = geom.asPolyline()
                # print("self.points",self.points)
                QgsMessageLog.logMessage("len=" + str(geom.asPolyline()), "Console(Arc)")
                i = 0
                for pt in self.points:
                    self.rubber.addPoint(pt, i)
                    i = i + 1
                    pass
                # QgsMessageLog.logMessage("len 2 = " + str(self.rubber.numberOfVertices()), "Console(Arc)")
                self.rubber.show()
                pass
        elif event.button() == Qt.RightButton:
            # self.row_lay.startEditing()
            self.coords = []
            self.count = 0
            self.draggable = False
            self.dragging = False
            self.geomlist = []
            self.fids=[]
            # self.parent.splitPoints = []
            blade = QgsGeometry.fromWkt(self.arc.asWkt())
            # print(blade.asWkt())
            # self.parent.layer = self.layer
            self.coor = self.rubber.asGeometry().convertToType(QgsWkbTypes.LineGeometry).asPolyline()
            # sp_cord=[self.coor[0],self.coor[-1]]
            rub_geom = self.rubber.asGeometry()
            total_len=rub_geom.length()
            cord_len=len(self.coor)
            digit=int(self.valus)
            # required_ver=cord_len/digit
            # print("required_ver",required_ver)
            # dis_pts = total_len / required_ver
            dis_pts = total_len /self.valus
            # print("dis_pts",dis_pts)
            self.poi=rub_geom.asPolyline()
            if (len(self.poi) > 0):
                i = 0
                while (i < (len(self.poi) - 2)):
                    ptn1 = QgsPoint(self.poi[i])
                    # print"ptn1", ptn1
                    while ((i + 1) < (len(self.poi) - 1)):
                        ptn2 = QgsPoint(self.poi[i + 1])
                        # print"ptn2", ptn2
                        dist = QgsGeometry.fromPolyline([ptn1, ptn2])
                        dis=dist.length()
                        if (dis < dis_pts):
                            self.poi.pop(i + 1)
                            continue
                            pass
                        break
                    i += 1

            final_vert=[]
            if self.layer.selectedFeatureCount() == 1:
                blade = QgsGeometry.fromPolylineXY(self.poi)
                crs = str(self.layer.crs().authid())
                dscrs=str(QgsProject.instance().crs().authid())
                sourceCrs = QgsCoordinateReferenceSystem(dscrs)
                destCrs = QgsCoordinateReferenceSystem(crs)
                tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())
                blade.transform(tr)
                self.reshapePolygonByLine(blade)
                # for feat in self.layer.selectedFeatures():
                #     geom=feat.geometry()
                    # print(geom.wkbType())
                    # if geom.wkbType() in [QgsWkbTypes.MultiPolygon]:
                    #     ver_list = geom.asMultiPolyline()[0]
                    # else:
                    #     ver_list = geom.asPolyline()
                    # close1 = min([geom.closestSegmentWithContext(QgsPoint(self.coor[0]))])
                    # idx1=close1[2]
                    # # print("idx1",idx1)
                    # close2 = min([geom.closestSegmentWithContext(QgsPoint(self.coor[-1]))])
                    # idx2 = close2[2]
                    # # print("idx2", idx2)
                    # if idx1 > idx2:
                    #     self.poi.reverse()
                    #     geom_part1 = ver_list[idx1:]
                    #     geom_part2 = ver_list[:idx2]
                    #     final_vert.append(geom_part2)
                    #     final_vert.append(self.poi)
                    #     final_vert.append(geom_part1)
                    #     pass
                    # else:
                    #     geom_part1=ver_list[:idx1]
                    #     # print("part1len",len(geom_part1))
                    #     final_vert.append(geom_part1)
                    #     final_vert.append(self.poi)
                    #     geom_part2 = ver_list[idx2:]
                    #     # print("part1len2", len(geom_part2))
                    #     final_vert.append(geom_part2)
                    # ab = itertools.chain.from_iterable(final_vert)
                    # geom_vert = list(ab)
                    # # print("final_vert", geom_vert)
                    # blade = QgsGeometry.fromPolyline(geom_vert)
                    # self.layer.changeGeometry(feat.id(), blade)

            else:
                self.iface.messageBar().pushInfo("Feature:", "Please select the only one Line feature ")

            mc = self.iface.mapCanvas()
            mc.refreshAllLayers()
            if self.rubber and len(self.coords) <= 0:
                    if self.rubber:
                        self.iface.mapCanvas().scene().removeItem(self.rubber)
                        self.rubber = None
                        self.coords = []
                        self.clearSnapIndicator()
                        self.rows = 0
                        pass

                    if self.temp:
                        self.iface.mapCanvas().scene().removeItem(self.temp)
                        self.temp = None
                        pass
                    if self.iconAction.isChecked():
                        self.iconAction.trigger()

                    return
                    pass       

    def canvasMoveEvent(self, event):

        try:
            self.pos = event.pos()
            # print('test',self.pos)
            # (retval, result) = self.snapper.snapToBackgroundLayers(self.pos)
            result = self.snapper.snapToMap(self.pos, None)
            if result:
                self.updateSnapIndicator(result.point())
            else:
                self.clearSnapIndicator()
            if self.dragging:
                self.pos = event.pos()
                # print("self.pos",self.pos)
                mapPt, layerPt = self.transformCoordinates(self.pos)
                # print(mapPt)
                if self.draggable:
                    pos = len(self.coords)
                    self.coords[pos - 2] = QgsPoint(mapPt.x(), mapPt.y())
                    self.rubber.reset()
                    self.arc.setPoints(self.coords)
                    geom = QgsGeometry.fromWkt(self.arc.asWkt())
                    # print("geom", geom)
                    self.points = geom.asPolyline()
                    # print(self.points)
                    i = 0
                    for pt in self.points:
                        self.rubber.addPoint(pt, i)
                        i = i + 1
                        pass
                    self.rubber.show()
                    
                    # self.highlight = QgsHighlight(self.iface.mapCanvas(), QgsGeometry.fromWkt(self.arc.asWkt()),
                    #                               self.layer)
                    # self.highlight.setColor(QColor("Blue"))
                    # self.highlight.setWidth(5)
                    # self.highlight.setFillColor(QColor("Green"))
                    pass
                else:
                    self.rubber.reset()
                    self.arc.setPoints(self.coords + [QgsPoint(mapPt.x(), mapPt.y())])
                    geom = QgsGeometry.fromWkt(self.arc.asWkt())
                    self.points = geom.asPolyline()
                    i = 0
                    for pt in self.points:
                        self.rubber.addPoint(pt, i)
                        i = i + 1
                        pass
                    self.rubber.show()
                    print(self.rubber)
                    # self.highlight = QgsHighlight(self.iface.mapCanvas(), QgsGeometry.fromWkt(self.arc.asWkt()),
                    #                               self.layer)
                    # self.highlight.setColor(QColor("Blue"))
                    # self.highlight.setWidth(5)
                    # self.highlight.setFillColor(QColor("Green"))
                    pass
            pass
        except Exception as e:
            QgsMessageLog.logMessage(str(e), "Console(Arc)")
            pass
        pass

    def transformCoordinates(self, canvasPt):
        return (self.toMapCoordinates(canvasPt), self.toLayerCoordinates(self.layer, canvasPt))


    def updateSnapIndicator(self, newPosition):
        # print("updateSnapIndicator")
        if self.snapIndicator == None:
            self.initialiseSnapIndicator(newPosition)
        else:
            self.snapIndicator.setCenter(newPosition)

    def initialiseSnapIndicator(self, position):
        # print("initialiseSnapIndicator")
        self.snapIndicator = QgsVertexMarker(self.canvas)
        self.snapIndicator.setIconType(QgsVertexMarker.ICON_CROSS)
        self.snapIndicator.setIconSize(10)
        self.snapIndicator.setColor(QColor("Magenta"))
        self.snapIndicator.setPenWidth(3)

    def clearSnapIndicator(self):
        # print("clearSnapIndicator")
        if self.snapIndicator != None:
            self.canvas.scene().removeItem(self.snapIndicator)
            self.snapIndicator = None

    def pointLayer(self, layer,rubber):
        # print(" pointLayer")
        curLayerCRS = layer.crs().authid()
        vl = None
        for layer in QgsMapLayerRegistry.instance().mapLayers().values():
            if layer.name() == str("Attribute_Error"):
                # Lexists = "true"
                vl = layer
                # print "vl",vl
                # pr = vl.dataProvider()
                vl.startEditing()
                self.vl = vl

        if vl is None:
            self.layerGeometryType = 'Polygon'
            self.vl = QgsVectorLayer(self.layerGeometryType + '?crs=' + str(curLayerCRS), "Attribute_Error", "memory")
            # pr=vl.dataProvider()
            pr = self.vl.dataProvider()
            pr.addAttributes([QgsField('FID', QVariant.Int)])
            self.vl.updateFields()
        # geom=rubber.asGeometry()
        bf_inGeom = rubber.buffer(4.5, 1, 2, 2, 5)
        outGeom = QgsFeature()
        outGeom.initAttributes(1)
        outGeom.setAttribute(0, 1)
        outGeom.setGeometry(bf_inGeom)
        self.vl.dataProvider().addFeatures([outGeom])
        QgsMapLayerRegistry.instance().addMapLayer(self.vl)
        pass
    def featadd(self,fid):
        # print("fid",fid)
        self.fids.append(fid)
        pass

    def modified(self,id):
        # print("modifyid", id)
        self.fids.append(id)
        pass
    
