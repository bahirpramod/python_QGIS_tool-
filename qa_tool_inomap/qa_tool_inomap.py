# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QAToolInomap
                                 A QGIS plugin
 checking orphan feature 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by genessy
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication, QLabel, QStyle
from qgis.gui import *
from qgis.core import *
from qgis.core import QgsMessageLog
from PyQt5 import *
import qgis
import json
import psycopg2
import  datetime
import subprocess
import xlrd
from qgis.core import QgsApplication
from math import degrees, atan2
import sys
from collections import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qa_tool_inomap_dialog import QAToolInomapDialog
import os.path


class QAToolInomap:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QAToolInomap_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QA Tool Inomap')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.lane_id=[]
        self.error_list = []

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QAToolInomap', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qa_tool_inomap/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'QA Tool Inomap V1'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QA Tool Inomap'),
                action)
            self.iface.removeToolBarIcon(action)
    
    def onCancelClick(self):
        # self.dlg.progressBar.setValue(0)
        self.chkbox()
        self.dlg.reject()
    
    def getConfig(self):
        self.data = {}
        path = os.path.join(self.plugin_dir, "AppConfig.json")
        try:
            if os.path.exists(path):
                with open(path) as json_file:
                    self.data = json.load(json_file)
                pass

            pass
        except Exception as e:
            err1 = "unable read data:-\n" + str(e)
            QMessageBox.information(self.dlg, "Error", err1)
            pass
        pass

        if True:
            self.host = self.data['host']
            self.port = self.data['port']
            self.userid = self.data['user']
            self.pwd = self.data['password']
            self.databas = self.data['database']
            # self.schema=self.data['schema']
            self.TestConnection()
    
    def TestConnection(self):
        flag = False
        try:
            self.conn = psycopg2.connect(database=self.databas, user=self.userid, password=self.pwd, host=self.host,
                                    port=int(self.port))
            self.db_link = self.conn.cursor()
            flag = True
            # print("self.schema",self.schema)
            QMessageBox.information(self.dlg, "Result", 'Database Connected Successfully')
        except Exception as e:
            flag = False
            self.dbError = str(e)
            QMessageBox.critical(self.dlg, "Error", self.dbError)
        finally:
            return flag
    def addlayers(self):
        self.layer=QgsProject.instance().mapLayers().values()
        self.dlg.comboBox.clear()
        self.dlg.comboBox.addItems([layer.name() for layer in self.layer if  layer.name() == 'vw_lane_lines' or layer.name() == 'lane_lines' ]) 
   
    def add_schema(self):
        schema_lst=self.get_schema()
        self.dlg.comboBox.clear()
        # self.dlg.comboBox_2.clear()
        self.dlg.comboBox.addItems(schema_lst)
        # self.dlg.comboBox_2.addItems(schema_lst)
        self.schema=self.dlg.comboBox.currentText()
        # self.schema_2=self.dlg.comboBox_2.currentText()
    def set_schema(self):
        self.schema=self.dlg.comboBox.currentText()
        self.dlg.tabWidget.setVisible(True)
       
        
        
    def get_schema(self):
        schemaList=[]
        # sql = "select * from information_schema.schemata where schema_name not like 'pg_%' and schema_name <>'information_schema' order by schema_name;"
        sql = "select * from information_schema.schemata where schema_name not like 'p%' and schema_name NOT LIKE 'i%' and schema_name NOT LIKE 'm%' and schema_name <>'information_schema' order by schema_name;"
        # self.cursor.execute(sql)
        
        isExecute, rows, sException_reson = self.sql_FeachRecords(sql)
        # self.conn.close()
        self.cursor = None
        if isExecute == False:
            QMessageBox.information(self.dlg, 'Get Schemas',
                                    "Unable to fetch Schemas from database:-" + str(sException_reson))
        else:
            for row in rows:
                schemaList.append(row[1])
            # print("schemaList", schemaList)
            return schemaList
        # print("schemaList", schemaList)
        pass
    def sql_FeachRecords(self,sql,isCommit = False ,isSilent = True,isCloseConn = True):
        isExecute = False
        sException_reson = None
        cur =None
        rows =None
        QgsMessageLog.logMessage("Query :- " + str(sql), "pgSetting",Qgis.Info)
        # cur = self.cursor
        try:
            # print("sql",sql)
            self.cursor= self.conn.cursor()
            self.cursor.execute(sql)
            if isCommit == True:
                self.conn.commit()
            rows = self.cursor.fetchall()
            # print("row f",rows)
            isExecute = True
        except Exception as e:
            sException_reson = str(sys.exc_info())
            if isSilent== False:
                QMessageBox.information(self.dlg, 'schema', "Unable to Feach Records Query reason:-" + str(sys.exc_info()))
            QgsMessageLog.logMessage("Unable to Feach Records Query reason :-" + str(e), "Schema",Qgis.Info)
            isExecute = False
        finally:
            if isCloseConn == True:
                # self.conn.close()
                self.cursor = None
        return isExecute,rows,sException_reson  

    def run_rule(self):
        # self.find_intersect_seg()
        if self.dlg.checkBox_0.isChecked() == True:
            self.vw_lane_lines_check()
        if self.dlg.checkBox_1.isChecked() == True:
            self.segment_table_check()
        if self.dlg.checkBox_2.isChecked() == True:
            self.lane_table_check()
        if self.dlg.checkBox_3.isChecked() == True:
            self.transition_table_check()
        if self.dlg.checkBox_4.isChecked() == True:
            self.vw_lane_poly_check()
        if self.dlg.checkBox_5.isChecked() == True:
            self.vw_segment_poly_check()
        if self.dlg.checkBox_6.isChecked() == True:
            self.vw_transition_line_check()
        # self. no_error()
        QMessageBox.information(self.dlg, 'Completed',
                                        "Please check the 'Error tables'.")
        
        
        pass
    def vw_lane_lines_check(self):
        dctErrPnts = defaultdict()
        # Rule 0 Error ---vw_lane_lines_check----a)check vertex of line (nan,null etc)
        '''discription'''
        '''check vertex of line if z axix vertex is nan/ nul then is invalide geom'''
        lane_id_vw_lane_lines = self.get_ids('lane_id','vw_lane_lines')
        left_lane_id_l =  self.get_ids('left_lane_id','lanes')
        right_lane_id_l = self.get_ids('right_lane_id','lanes')
        for l_id_vw_l in lane_id_vw_lane_lines:
            # print(l_id_vw_l)
            sql = f"SELECT ST_AsGeoJSON(geom):: json from {self.schema}.lane_lines where lane_id='" + l_id_vw_l[0] + "'"
            # sql = f"SELECT ST_ASTEXT(ST_AsGeoJSON(geom)) from {self.schema}.lane_lines where lane_id='" + l_id_vw_l[0] + "'"
            self.db_link.execute(sql)
            crds = self.db_link.fetchall()
            crds[0]
            lane_line_geom_json = crds[0][0]['coordinates']
            # print("lane_line_geom_json",lane_line_geom_json)
            for crd in lane_line_geom_json:
                # print(crd[2])
                if crd[2]=='null' or crd[2]=='nan'or crd[2]=='Null' or crd[2]=='Nan'or crd[2]=='NULL' or crd[2]=='NAN':
                    print(crd[2])
                    name="segment_id not in vw_lane_poly"
                    # print("lane id not in vw_lane_poly",s_id_s[0])
                    dctErrPnts[l_id_vw_l] = [name]
        for lid in lane_id_vw_lane_lines:
            if lid not in left_lane_id_l and lid not in right_lane_id_l :
                # print("lid",lid)
                name="lane_line_id not in vw_lane_poly"
                dctErrPnts[lid] = [name]
          
        self.load_error_list('vw_lane_line_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
           
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()


    def segment_table_check(self):
        print(1)
        # Rule 1 Error ---segment table Check----a)segment_id check in  lanes table and vw_lane_poly( segment_id) .
        '''discription'''
        '''if segment_id not present in lanes table and vw_lane_poly means segment is orphan'''
        
        segment_id_seg = self.get_ids('segment_id','segment')
        segment_id_inLane = self.get_ids('segment_id','lanes')
        segment_id_p = self.get_ids('segment_id','vw_lane_poly')
        i=0
        error_mrk = []
        dctErrPnts = defaultdict()
        # print(" self.segment_id_seg", self.segment_id_seg)
        for s_id_s in segment_id_seg:
            i+=1
            # print(i)
            if s_id_s in segment_id_inLane:
                pass
            else:
                name="segment_id not in lanes table"
                # print("segment id not in lanes table",s_id_s[0])
                dctErrPnts[s_id_s[0]] = [name]
        
        for s_id_s1 in segment_id_seg:
            if s_id_s1 in segment_id_p:
                pass
            else:
                pass
                name="segment_id not in vw_lane_poly"
                # print("lane id not in vw_lane_poly",s_id_s[0])
                dctErrPnts[s_id_s1[0]] = [name]
        dt_string = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        # print('Starttime: ',dt_string)       
        # self.load_error_list(f'{self.schema}segment_table_check{dt_string}')
        self.load_error_list(f'segment_table_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()
        
   
    def lane_table_check(self):
        print(2)
        error_mrk = []
        dctErrPnts = defaultdict()
        # Rule 2 Error ---Lane Table Check - - --a)Lane id not present in lane poly
        '''discription'''
        '''checks lane_id lanes table in lane poly lane_id  
        if not exist in lane poly table then geom not 
        exist means lane id in lane table is orphan'''
        
        lane_id_l =  self.get_ids('lane_id','lanes')
        lane_id_p = self.get_ids('lane_id','vw_lane_poly')
        for l_id_l in lane_id_l:
            if l_id_l in lane_id_p :
                pass
            else:
                pass
                name="lane id not in vw_lane_poly"
                # print("lane id not in vw_lane_poly",l_id_l[0])
                dctErrPnts[l_id_l[0]] = [name]

        # Rule 2 Error ---Lane Table Check - - --b) Left & Right Lane id not present in lane lines
        '''discription'''
        '''checks in lanes table left lane id and right lane id in lane lines 
          if not exist means its orphan left and right lane_ids'''
       
        left_lane_id_l =  self.get_ids('left_lane_id','lanes')
        right_lane_id_l = self.get_ids('right_lane_id','lanes')
        lane_id_lines = self.get_ids('lane_id','vw_lane_lines')
        for l_l_id_l in left_lane_id_l:
            if l_l_id_l in lane_id_lines:
                pass
            else:
                name="left_lane_id not present in vw_lane_lines"
                pass
                # print("left_lane_id not present in vw_lane_lines",l_l_id_l)
                dctErrPnts[l_l_id_l[0]] = [name]

        for r_l_id_l in right_lane_id_l:
            if r_l_id_l in lane_id_lines:
                pass
            else:
                pass
                name="right_lane_id not present in vw_lane_lines"
                # print("right_lane_id not present in vw_lane_lines",r_l_id_l)
                dctErrPnts[r_l_id_l[0]] = [name]

        # Rule 2 Error ---Lane Table Check - -C) lane table-sgment_id check in segment poly-segment_id
        '''discription'''
        '''lane table sgment_id not present in segment poly segment_id, it means segemnt is orphan'''

        segment_id_sp = self.get_ids('segment_id','vw_segment_poly')
        segment_id_l = self.get_ids('segment_id','lanes')
        for s_id_l in segment_id_l:
            if s_id_l in segment_id_sp:
                # print(123)
                pass
            else:
                pass
                name="segment id not present in vw_segment_poly"
                # print("segment id not present in vw_segment_poly", s_id_l)
                dctErrPnts[s_id_l[0]] = [name]
                
        self.load_error_list('lane_table_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()
        
    
    def transition_table_check(self):
        print(3)
        dctErrPnts = defaultdict()
        error_mrk = []
        # Rule 3 Error ---transition table Check -- a) transition table-transition_id to check in transition_id-vw_transition_line
        '''discription'''
        '''transition_id-transitions table is not present in transition_id in vw_transition_line then transition is orphan'''
        transition_id = self.get_ids('transition_id','transitions')
        transition_id_vw_l = self.get_ids('transition_id','vw_transition_line')
        for t_id_t in transition_id:
            if t_id_t in transition_id_vw_l :
                pass
                # print(123)
            else :
                name="transtion_id not present in vw_transtion_line"
                # print("transtion_id not present in vw_transtion_line", t_id_t)
                dctErrPnts[t_id_t[0]] = [name]

        #Rule 3 Error ---transition table Check -- b)Transition_entrance and exit_id not present in lane_id in lanes table
        '''discription'''
        '''checks  transitions entrance_id and exit_id in lane_id - lanes tables 
        if not exists means transtion is orphan'''
        transition_entrance_id =self.get_ids('entrance_id','transitions')
        transition_exit_id = self.get_ids('exit_id','transitions')
        lane_id_l = self.get_ids('lane_id','lanes')
        for en_id_t in transition_entrance_id:
            if en_id_t in lane_id_l : #  lane_id_l is lane_id of lanes table
                # print(123)
                pass
            else:
                pass
                # print(" transtion_entrance_id not presemnt  in leans table-lane_id", en_id_t)
                name="transtion_entrance_id not presemnt  in leans table-lane_id"
                dctErrPnts[en_id_t[0]] = [name]
        for ex_id_t in transition_exit_id:
            if ex_id_t in lane_id_l :
                # print(123)
                pass
            else:
                pass
                # print("transtion_exit_id not present in lanes table-lane id ", ex_id_t)
                name="transtion_exit_id not present in lanes table-lane id "
                dctErrPnts[ex_id_t[0]] = [name]

        # Rule 3 Error ---transition table Check -- c)Transition_entrance and exit_id not present in lane_id in vw_lane_poly
        '''discription'''
        '''checks  transitions entrance_id and exit_id in lane_id - vw_lanes poly 
        if not exists means transtion is orphan'''
       
        lane_id_p = self.get_ids('lane_id','vw_lane_poly')
        for en_id_t in transition_entrance_id:
            if en_id_t in lane_id_p : #  lane_id_l is lane_id of lanes table
                # print(123)
                pass
            else:
                pass
                # print(" transtion_entrance_id not presemnt  in vw_lane_poly", en_id_t)
                name="transtion_entrance_id not presemnt  in vw_lane_poly"
                dctErrPnts[en_id_t[0]] = [name]
      
        for ex_id_t in transition_exit_id:
            if ex_id_t in lane_id_l :
                # print(123)
                pass
            else:
                pass
                # print("transtion_exit_id not present in vw_lane_poly ", ex_id_t)
                name="transtion_exit_id not present in vw_lane_poly "
                dctErrPnts[ex_id_t[0]] = [name]
      
        self.load_error_list('transition_table_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
           
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()


    def vw_lane_poly_check(self):
        print(4)
        dctErrPnts = defaultdict()
        error_mrk = []
        #Rule 4 Error ---vw_lane_poly Check -- a)left_lane_id & right_lane_id check present in lane_lines
        '''discription'''
        '''left_lane_id & right_lane_id in vwlane_poly check present in lane_lines lane_id if not present then poly is orpan'''
       
        left_lane_id_vw_p =self.get_ids('left_lane_id','vw_lane_poly')
        
        right_lane_id_vw_p = self.get_ids('right_lane_id','vw_lane_poly')
        lane_id_lines = self.get_ids('lane_id','vw_lane_lines')
        for l_l_id_p in left_lane_id_vw_p:
            if l_l_id_p in lane_id_lines:
                # print(123)
                pass
            else:
                name="left_lane-id in vw_lane_poly not present in vw_lane_lines"
                dctErrPnts[l_l_id_p[0]] = [name]
       
        for r_l_id_p in right_lane_id_vw_p:
            if r_l_id_p in lane_id_lines:
                # print(123)
                pass
            else:
                name="right_lane-id in vw_lane_poly not present in vw_lane_lines"
                dctErrPnts[r_l_id_p[0]] = [name]

        #Rule 4 Error ---vw_lane_poly Check -- b) lane_id check present in lanes table
        '''discription'''
        '''lane_id  in vw_lane_poly check present in lanes table lane_id if not present then poly is orpan'''
        
        lane_id_vw_p =self.get_ids('lane_id','vw_lane_poly')
        lane_id_vw_lt = self.get_ids('lane_id','lanes')
        for l_id_vw_p in lane_id_vw_p:
            if l_id_vw_p in lane_id_vw_lt :
                pass
            else:
                name="lane-id in vw_lane_poly not present in lanes table"
                dctErrPnts[l_id_vw_p[0]] = [name]
        #Rule 4 Error ---vw_lane_poly Check -- c) segment_id check present in segment table & segment poly
        segment_id_vw_p =self.get_ids('segment_id','vw_lane_poly')
        segment_id_vw_sp =self.get_ids('segment_id','vw_segment_poly')
        segment_id_vw_st = self.get_ids('segment_id','segment')
        for s_id_vw_p in segment_id_vw_p:
            if s_id_vw_p in segment_id_vw_sp:
                pass
            else :
                name="segment-id of vw_lane_poly not present in vw_segment_poly"
                dctErrPnts[l_id_vw_p[0]] = [name] 
        for s_id_vw_p in segment_id_vw_p:
            if s_id_vw_p in segment_id_vw_st:
                pass
            else :
                name="segment-id of vw_lane_poly not present in vw_segment tables"
                dctErrPnts[l_id_vw_p[0]] = [name] 
      
        self.load_error_list('vw_lane_poly_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()
        
    def vw_segment_poly_check(self): 
        print(5)
        dctErrPnts = defaultdict()
        error_mrk = []
        #Rule 5 Error ---vw_segment_poly Check -- a)segment_id and lane_id check in vw_lane_poly 
        '''discription'''
        ''' segment_id and lane_id--vw_segment_poly not present in segment_id--vw_lane_poly then segment is orphan'''
        
        segment_id_vw_s = self.get_ids('segment_id','vw_segment_poly')
        lane_id_vw_s = self.get_ids('lane_id','vw_segment_poly')
        segment_id_vw_p =self.get_ids('segment_id','vw_lane_poly')
        lane_id_vw_p =self.get_ids('lane_id','vw_lane_poly')
        for s_id_vw_s in segment_id_vw_s :
            if s_id_vw_s in segment_id_vw_p :
                pass
                # print(123)
            else:
                name-"segemnt_id  in vw_segment poly not present in vw_lane_poly"
                dctErrPnts[s_id_vw_s[0]] = [name]
       
        for l_id_vw_s in lane_id_vw_s:
            if l_id_vw_s in lane_id_vw_p:
                pass
                # print(123)
            else:
                name="lane_id  in vw_segment poly not present in vw_lane_poly"
                dctErrPnts[l_id_vw_s[0]] = [name]
        

        #Rule 5 Error ---vw_segment_poly Check -- b)segment_id and lane_id check in segment table 
        '''discription'''
        ''' segment_id and lane_id--vw_segment_poly not present in segment_id--segment table then segment is orphan'''
        segment_id_seg = self.get_ids('segment_id','segment')
        for s_id_vw_s in segment_id_vw_s :
            if s_id_vw_s in segment_id_seg :
                pass
                # print(123)
            else:
                name-"segemnt_id  in vw_segment poly not present in segment table"
                dctErrPnts[s_id_vw_s[0]] = [name]
        
        #Rule 5 Error ---vw_segment_poly Check -- c)segment_id and lane_id check in lanes table 
        '''discription'''
        ''' segment_id and lane_id--vw_segment_poly not present in segment_id--segment table then segment is orphan'''
        segment_id_lanes = self.get_ids('segment_id','lanes')
        lane_id_lanes = self.get_ids('lane_id','lanes')
        for s_id_vw_s in segment_id_vw_s :
            if s_id_vw_s in segment_id_lanes :
                pass
                # print(123)
            else:
                name-"segemnt_id  in vw_segment poly not present in lanes table"
                dctErrPnts[s_id_vw_s[0]] = [name]
      
        for l_id_vw_s in lane_id_vw_s:
            if l_id_vw_s in lane_id_lanes:
                pass
                # print(123)
            else:
                name="lane_id  in vw_segment poly not present in lanes table"
                dctErrPnts[l_id_vw_s[0]] = [name]

        self.load_error_list('vw_segment_poly_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
         
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()

    def vw_transition_line_check(self):
        print(6)
        dctErrPnts = defaultdict()
        error_mrk = []
        #Rule 6 Error ---vw_transition_line Check -- a) lane_id  check in vw_lane_poly & lanes tables
        '''discription'''
        ''' lane_id--vw_transition_line not present in lane_id--vw_lane_poly then transition is orphan'''
        
        lane_id_vw_tl = self.get_ids('lane_id','vw_transition_line')
        lane_id_lanes = self.get_ids('lane_id','lanes')
        lane_id_vw_p = self.get_ids('lane_id','vw_lane_poly')
        for l_id_vw_tl in lane_id_vw_tl: 
            if l_id_vw_tl in lane_id_vw_p :
                pass
                # print(123)
            else:
                # print(l_id_vw_tl)
                name="lane_id of vw_transition_line is not present in vw_lane_poly"
                dctErrPnts[l_id_vw_tl[0]] = [name]
        for l_id_vw_tl in lane_id_vw_tl: 
            if l_id_vw_tl in lane_id_lanes :
                pass
                # print(123)
            else:
                # print(l_id_vw_tl)
                name="lane_id of vw_transition_line is not present in lanes table"
                dctErrPnts[l_id_vw_tl[0]] = [name]
        
       

        #Rule 6 Error ---vw_transition_line Check -- b) transition_id and check in transitions table 
        '''discription'''
        ''' ltransition_id--vw_transition_line not present in transitions table then transition is orphan'''
        transition_id_vw_tl = self.get_ids('transition_id','vw_transition_line')
        transition_id_vw_tb = self.get_ids('transition_id','transitions')
        for t_id_vw_tl in transition_id_vw_tl:
            if t_id_vw_tl in transition_id_vw_tb:
                pass
                # print(1234)
            else:
                name="transition_id of vw_transition_line is not present in transitions table"
                dctErrPnts[t_id_vw_tl[0]] = [name]
        
        # #Rule 6 Error ---vw_transition_line Check -- c) lane id in lane poly check transition line lane_id
        # for l_id_vw_pl in lane_id_vw_p: 
        #     if l_id_vw_pl in lane_id_vw_tl :
        #         pass
        #         # print(123)
        #     else:
        #         # print(l_id_vw_tl)
        #         name="lane_id of vw_lane_poly is not present in transition_line"
        #         dctErrPnts[l_id_vw_pl[0]] = [name]

        self.load_error_list('vw_transition_line_check')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()

    def get_ids(self,id, table):
        # self.schema = self.data['schema'] 
        # print("self.schema ",self.schema )
        sql = f"SELECT {id} from {self.schema}.{table}"
        # print("sql",sql)
        self.db_link.execute(sql)
        ids = self.db_link.fetchall()
        return ids
    def get_ids_mpc(self,sql):
        self.db_link.execute(sql)
        ids = self.db_link.fetchall()
        return ids
     
    
    def load_error_list(self,name):
        # self.errorPointFeatures = []
        fields = QgsFields()
        fields.append(QgsField('ID', QVariant.String))
        fields.append(QgsField('error_name', QVariant.String))
        # fields.append(QgsField('Right_lane_id', QVariant.String))

        self.nlayer = QgsVectorLayer('None', name, 'memory')
        # prov = layer.dataProvider()
        self.nlayer.dataProvider().addAttributes(fields)
        self.nlayer.updateFields()
        self.nlayer.startEditing()

    def updateErrorPointFeatures(self,attrList):
        # print("dghfgfg")
        # print("err_feats",err_feats)
        self.feature = QgsFeature()
        self.feature.setAttributes(attrList )
        self.nlayer.addFeature(self.feature)
        
    def add_layer(self):
        self.nlayer.commitChanges()
        # add new layer to map canvas
        QgsProject.instance().addMapLayer(self.nlayer)

    def help(self):
        '''exel sheet password is =pramoddb'''
        # Path to your XLS file
        # xls_path = 'path/to/your/help_file.xls'
        self.dlg.tabWidget.setVisible(False)
        path2 = os.path.dirname(__file__)
        path2 = path2.replace("\\", "/")
        xls_path = os.path.join(path2, "QA Tool Docs.xlsx")

        if os.path.isfile(xls_path):
            os.system(f'start excel "{xls_path}"')
        else:
            QMessageBox.warning(self, 'Error', 'Help file not found.')

        # if os.path.isfile(xls_path):
        #     try:
        #         subprocess.Popen(['start', 'excel', xls_path], shell=True)
        #     except Exception as e:
        #         QMessageBox.critical(self, 'Error', f'Error opening Excel: {str(e)}')
        # else:
        #     QMessageBox.warning(self, 'Error', 'Help file not found.')
    def check_mpc_query(self):
        dctErrPnts=defaultdict()
        # rule 0 chechk Lane lines:
        if self.dlg.checkBox_7.isChecked() == True:
            # rule 0 chechk Lane lines: a) '''null vertex'''
            sql=f"select lane_id from {self.schema}.vw_lane_lines where st_astext(geom) like '%NaN%' and is_deleted=false and type not in ('Unpopulated','Unpopulated(13)')"
            # print(sql)
            lane_id=self.get_ids_mpc(sql)
            # print("mpc",lane_id)
            name='null vertex'
            for ids in lane_id:
                dctErrPnts[ids] = [name]

            # rule 0 chechk Lane lines: b) -------- invalid geom --------
            sql=f"select lane_id from {self.schema}.vw_lane_lines where st_isvalid(geom)=false and is_deleted=false"
            lane_id=self.get_ids_mpc(sql)
            # print("mpc",lane_id)
            name='invalid geom'
            for ids in lane_id:
                dctErrPnts[ids] = [name]

            # rule 0 chechk Lane lines: c) -------- nullgeom --------
            sql=f"select lane_id from {self.schema}.vw_lane_lines where geom is null and is_deleted=false"
            lane_id=self.get_ids_mpc(sql)
            # print("mpc",lane_id)
            name='null geom'
            for ids in lane_id:
                dctErrPnts[ids] = [name]


            self.load_error_list('mpc_chk_Lane_lines')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()

        # rule 2 segment table: 
        if self.dlg.checkBox_8.isChecked() == True:
            
            # rule 2 segment table: a) '''------- segment present but lane not present ------'''
            sql=f"select segment_id from {self.schema}.segment where segment_id not in (select distinct segment_id from {self.schema}.lanes);"
            segment_id_segment=self.get_ids_mpc(sql)
            for s_id_s in segment_id_segment :
                name="segment present but lane not present "
                dctErrPnts[s_id_s[0]] = [name]

            # rule 2 segment table: b) '''----- extra segments -----'''
            sql=f"select segment_id from {self.schema}.segment where segment_id not in (select distinct segment_id from {self.schema}.vw_segment_poly where is_deleted=false);"
            segment_id_segment_e=self.get_ids_mpc(sql)
            for s_id_s_e in segment_id_segment_e :
                name="segment present but lane not present "
                dctErrPnts[s_id_s_e[0]] = [name]
        
            self.load_error_list('mpc_chk_segment table')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()

        # rule 3 Lanes table : a) '''-------lanes present but lane line missing------'''
        
        '''left'''
        if self.dlg.checkBox_9.isChecked() == True:
            # print("hgcifh")
            sql=f"select lane_id from {self.schema}.lanes where left_lane_id not in (select lane_id from {self.schema}.vw_lane_lines) and segment_id in (Select distinct segment_id from {self.schema}.vw_segment_poly where is_deleted=false);"
            lane_id_lanes=self.get_ids_mpc(sql)
            for l_id_l in lane_id_lanes :
                name="lanes present but lane line missing"
                dctErrPnts[l_id_l[0]] = [name]
                '''right'''
            sql=f"select lane_id from {self.schema}.lanes where right_lane_id not in (select lane_id from {self.schema}.vw_lane_lines) and segment_id in (Select distinct segment_id from {self.schema}.vw_segment_poly where is_deleted=false);"
            lane_id_lanes=self.get_ids_mpc(sql)
            for l_id_l in lane_id_lanes :
                name="lanes present but lane line missing"
                dctErrPnts[l_id_l[0]] = [name]
        

            self.load_error_list('mpc_chk_Lanes table')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()

        # rule 4 transition table :
        if self.dlg.checkBox_10.isChecked() == True:
            # rule 4 transition table : a) transition_id check in transitin line

            # sql=f"select transition_id from {self.schema}.vw_transition_line where transition_id not in (select distinct transition_id from {self.schema}.transitions) and is_deleted=false;"
            sql=f"select * from {self.schema}.transitions where transition_id not in (select distinct transition_id from {self.schema}.vw_transition_line) "
            transition_id_t=self.get_ids_mpc(sql)
            for t_id_t in transition_id_t :
                name="transition present but transition line missing"
                dctErrPnts[t_id_t[0]] = [name]
            
            # rule 4 transition table : b) entrance_id check in lane poly
            sql=f"select entrance_id from {self.schema}.transitions where entrance_id not in (select distinct lane_id from {self.schema}.vw_lane_poly)"
            entrance_id_t=self.get_ids_mpc(sql)
            for e_id_t in entrance_id_t :
                name="entrance_id present but lane _id missing in poly"
                dctErrPnts[e_id_t[0]] = [name]

                # rule 4 transition table : b) exit_id check in lane poly
                sql=f"select exit_id from {self.schema}.transitions where exit_id not in (select distinct lane_id from {self.schema}.vw_lane_poly)"
                exit_id_t=self.get_ids_mpc(sql)
                for ex_id_t in exit_id_t :
                    name="exit_id present but lane _id missing in poly"
                    dctErrPnts[ex_id_t[0]] = [name]
            self.load_error_list('mpc_chk_transition table')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()
      
        # rule 4 Lanes poly:
        if self.dlg.checkBox_11.isChecked() == True:
            # rule 4 Lanes poly: a)'''--------- left lane poly orphan (lane lines deleted lane poly present)--------'''
         
            sql=f"select left_lane_id from {self.schema}.vw_lane_poly where left_lane_id not in (select distinct lane_id from {self.schema}.vw_lane_lines  where  is_deleted=false) and is_deleted = false;"
            left_lane_id_poly=self.get_ids_mpc(sql)
            # print("left_lane_id_poly",left_lane_id_poly)
            for l_l_id_p in left_lane_id_poly :
                name="poly is present but  lane line delete"
                dctErrPnts[l_l_id_p[0]] = [name]

            # rule 4 Lanes poly: b)  ''' --------- right lane poly orphan (lane lines deleted lane poly present)--------'''
           
            sql=f"select right_lane_id from {self.schema}.vw_lane_poly where right_lane_id not in (select distinct lane_id from {self.schema}.vw_lane_lines  where  is_deleted=false ) and is_deleted = false;"               
            right_lane_id_poly=self.get_ids_mpc(sql)
            for r_l_id_p in right_lane_id_poly :
                name="poly is present but vw_lane line delete"
                dctErrPnts[r_l_id_p[0]] = [name]
            
            # rule 4 Lanes poly: c) '''--- lane poly lane id not in lanes ---'''
            
            sql=f"select lane_id from {self.schema}.vw_lane_poly where lane_id not in (select distinct lane_id from {self.schema}.lanes) and is_deleted=false;"
            lane_id_poly=self.get_ids_mpc(sql)
            for l_id_p in lane_id_poly :
                name="vw_lane_poly lane_id not in lanes"
                dctErrPnts[l_id_p[0]] = [name]
            
            self.load_error_list('mpc_chk_vw_Lane_poly')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()

        # rule 5 segment poly
        if self.dlg.checkBox_12.isChecked() == True:
            # rule 5 segment poly: a) '''------ segment poly present but lane poly missing ------'''
            sql=f"select segment_id from {self.schema}.vw_segment_poly where segment_id not in (select distinct segment_id from {self.schema}.vw_lane_poly where is_deleted=false)and is_deleted=false;"
            segment_id_segment_p=self.get_ids_mpc(sql)
            for s_id_s_p in segment_id_segment_p :
                name="segment poly present but lane poly missing"
                dctErrPnts[s_id_s_p[0]] = [name]
        
            self.load_error_list('mpc_chk_vw_segment poly')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()

        # rule 6 transition line --- a)lane id missing in lane poly
        if self.dlg.checkBox_13.isChecked() == True:
            sql=f"select lane_id from {self.schema}.vw_transition_line where lane_id not in (select distinct lane_id from {self.schema}.vw_lane_poly where is_deleted=false) and is_deleted=false;"
            # sql=f"select * from {self.schema}.transitions where transition_id not in (select distinct transition_id from {self.schema}.vw_transition_line) "
            lane_id_tl=self.get_ids_mpc(sql)
            for l_id_tl in lane_id_tl:
                name="lane id missing in lany poly"
                dctErrPnts[l_id_tl[0]] = [name]
            pass
            # rule 6 transition line --- b)transition id missing in transition table
            sql=f"select transition_id from {self.schema}.vw_transition_line where transition_id not in (select distinct transition_id from {self.schema}.transitions where is_deleted=false) and is_deleted=false;"
            # sql=f"select * from {self.schema}.transitions where transition_id not in (select distinct transition_id from {self.schema}.vw_transition_line) "
            tranition_id_tl=self.get_ids_mpc(sql)
            for t_id_tl in tranition_id_tl:
                name="transition_id missing in transition table"
                dctErrPnts[t_id_tl[0]] = [name]
            pass


            self.load_error_list('mpc_chk_vw_transition line')
            for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
                self.updateErrorPointFeatures([ids,feats[0]] )
            self.add_layer()
        QMessageBox.information(self.dlg, 'Completed',
                                        "Please check the 'Error tables'.")
    def help_2(self):
        '''exel sheet password is =pramoddb'''
        # Path to your XLS file
        # xls_path = 'path/to/your/help_file.xls'
        self.dlg.tabWidget.setVisible(False)
        path2 = os.path.dirname(__file__)
        path2 = path2.replace("\\", "/")
        xls_path = os.path.join(path2, "QA Tool Docs_1.xlsx")

        if os.path.isfile(xls_path):
            os.system(f'start excel "{xls_path}"')
        else:
            QMessageBox.warning(self, 'Error', 'Help file not found.')
    
    def find_intersect_seg(self): 
        # print("self.schema",self.schema)
        self.dlg.progressBar.show()
        dctErrPnts = defaultdict()
        l=[]
        lane_id_line=self.get_ids('lane_id','vw_lane_lines')  
        # print("lane_id_line",lane_id_line)  
        count=len(lane_id_line)  
        prg = 0 
        for l_id_l in lane_id_line:
            
            sql=f"select distinct b.segment_id from  {self.schema}.vw_lane_lines a join {self.schema}.lanes b on '{l_id_l[0]}'=b.left_lane_id where a.is_deleted=false"
            # print("sql",sql)
            self.db_link.execute(sql)
            segment_id_l_l = self.db_link.fetchall()
            # print("seg",segment_id_l_l[0][0])
            sql=f"select distinct b.segment_id from  {self.schema}.vw_lane_lines a join {self.schema}.lanes b on '{l_id_l[0]}'=b.right_lane_id where a.is_deleted=false"
            self.db_link.execute(sql)
            segment_id_l_r = self.db_link.fetchall()
            for id in segment_id_l_l:
                for ids in segment_id_l_r:
                    if id!=ids :
                        name="lane_id of lane_lines used in two segment"
                        dctErrPnts[l_id_l [0]] = [name]
            percent = prg / float(count) * 100
            self.dlg.progressBar.setValue(percent)
            prg += 1
        self.load_error_list('Chk duplicate lane_id ')
        for ids, feats in dctErrPnts.items():  # pntGeom = QgsGeometry().fromPointXY(iter[0])
            self.updateErrorPointFeatures([ids,feats[0]] )
        self.add_layer()
        QMessageBox.information(self.dlg, 'Completed',
                                        "Please check the 'Error tables'.")
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar.hide()
    
    def chkbox(self): 
         self.dlg.checkBox_0.setChecked(False)
         self.dlg.checkBox_1.setChecked(False)
         self.dlg.checkBox_2.setChecked(False)
         self.dlg.checkBox_3.setChecked(False)
         self.dlg.checkBox_4.setChecked(False)
         self.dlg.checkBox_5.setChecked(False)
         self.dlg.checkBox_6.setChecked(False)
         self.dlg.checkBox_7.setChecked(False)
         self.dlg.checkBox_8.setChecked(False)
         self.dlg.checkBox_9.setChecked(False)
         self.dlg.checkBox_10.setChecked(False)
         self.dlg.checkBox_11.setChecked(False)
         self.dlg.checkBox_12.setChecked(False)
         self.dlg.checkBox_13.setChecked(False)
         
            
         
            
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = QAToolInomapDialog()
            self.dlg.Cancel.clicked.connect(self.onCancelClick)
            self.dlg.Cancel_2.clicked.connect(self.onCancelClick)
            self.dlg.Cancel_3.clicked.connect(self.onCancelClick)
            self.dlg.comboBox.currentIndexChanged.connect(self.set_schema)
            self.dlg.Ok.clicked.connect(self.run_rule)
            self.dlg.Ok_2.clicked.connect(self.check_mpc_query)
            self.dlg.Ok_3.clicked.connect(self.find_intersect_seg)
            self.dlg.help.clicked.connect(self.help)
            self.dlg.help_2.clicked.connect(self.help_2)
            
            

        # show the dialog
        
        self.dlg.tabWidget.setVisible(False)
        self.dlg.progressBar.hide()
        self.dlg.progressBar.setValue(0)
        self.dlg.show()
        self.getConfig()
        self.add_schema()
        self.dlg.tabWidget.setVisible(False)
        self.chkbox()
        
        # self.set_schema()
        
        # self. addlayers()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        '''enhance-ment '''

''' lane poly check'''
# segment id check in segment poly & segment tables 
