# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PTPTools
                                 A QGIS plugin
 Tools For PTP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-08
        copyright            : (C) 2021 by Sibin Sarmadan
        email                : sibinsa@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Sibin Sarmadan'
__date__ = '2021-03-08'
__copyright__ = '(C) 2021 by Sibin Sarmadan'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *

from qgis.analysis import (QgsGeometrySnapper,
                           QgsGeometrySnapperSingleSource,
                           QgsInternalGeometrySnapper)

import shapely

from shapely.wkt import dumps, loads


class PTPTopologyCheckerAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    RULE = 'RULE'

    rules = ['Must Not Intersect or touch interior','Must Not Self-Intersect',
             'Must Not Self-Overlap','Must Not Overlap','Must Not Have Gap'
            ,'Must Not Have Dangle','Must Not Have Pseudo Node',
             'Must Not Have Duplicate Feature','Must Not Have Invalid Geometry','Must Not Have Multipart Geometry','Merge with same Sub class']
    polygonTypes = [QgsWkbTypes.Polygon , QgsWkbTypes.PolygonZ, QgsWkbTypes.PolygonZM,
                 QgsWkbTypes.MultiPolygon, QgsWkbTypes.MultiPolygonZ, QgsWkbTypes.MultiPolygonZM]

    lineTypes = [QgsWkbTypes.LineString , QgsWkbTypes.LineStringZ, QgsWkbTypes.LineStringZM,
                 QgsWkbTypes.MultiLineString, QgsWkbTypes.MultiLineStringZ, QgsWkbTypes.MultiLineStringZM]

    pointTypes = [QgsWkbTypes.Point , QgsWkbTypes.PointZ , QgsWkbTypes.PointZM ,
                 QgsWkbTypes.MultiPoint , QgsWkbTypes.MultiPointZ , QgsWkbTypes.MultiPointZM ]


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorPoint, QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.RULE,
                self.tr('Topology Rule'),
                self.rules
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        # source = self.parameterAsSource(parameters, self.INPUT, context)
        sink =None
        dest_id=None

        rule=self.parameterAsEnum(parameters, self.RULE, context)

        if rule==1:
            (sink, dest_id)=self.mustNotSelfIntersect(parameters, context, feedback)
            pass

        elif rule==0:
            (sink, dest_id)=self.mustNotIntersect(parameters, context, feedback)
            pass

        elif rule==2:
            (sink, dest_id)=self.mustNotSelfOverlap(parameters, context, feedback)
            pass

        elif rule == 3:
            (sink, dest_id) = self.mustNotOverlap(parameters, context, feedback)
            pass

        elif rule == 4:
            (sink, dest_id) = self.mustNotHaveGap(parameters, context, feedback)
            pass


        elif rule == 5:
            (sink, dest_id) = self.mustNotHaveDangle(parameters, context, feedback)
            pass

        elif rule == 6:
            (sink, dest_id) = self.mustNotHavePseudoNode(parameters, context, feedback)
            pass

        elif rule == 7:
            (sink, dest_id) = self.mustNotHaveDuplicate(parameters, context, feedback)
            pass

        elif rule == 8:
            (sink, dest_id) = self.mustNotHaveInvalid(parameters, context, feedback)
            pass

        elif rule == 9:
            (sink, dest_id) = self.mustNotHaveMutipart(parameters, context, feedback)
            pass
        elif rule == 10:
            (sink, dest_id) = self.mustEdgematchwith(parameters, context, feedback)
            pass
        return {self.OUTPUT: dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'topology_checker'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Topology Checker'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Geometry Analysis'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PTPTopologyCheckerAlgorithm()


    def mustNotIntersect(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)


        if source.wkbType() not in self.lineTypes:
            feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Line type Layer')
            return (None,None)

        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        exp = "$id != {feat_id} and intersects(  $geometry , geom_from_wkt( '{geom}')) and not (" \
              "intersects(   start_point( $geometry) , geom_from_wkt( '{geom}')) or " \
              "intersects(   end_point( $geometry ), geom_from_wkt( '{geom}')))"
        # exp = "$id != {feat_id} and intersects(  $geometry , geom_from_wkt( '{geom}'))"
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            geom_wkt=feature.geometry().asWkt()
            req=QgsFeatureRequest().setFilterExpression(exp.format(feat_id=feature.id(),geom=geom_wkt))
            flag=0
            for feat in source.getFeatures(req):
                if feedback.isCanceled():
                    break
                    pass
                if feat.id()==feature.id():
                    continue
                geom=feat.geometry()
                d=geom.length()
                start_point=geom.interpolate(0)
                # feedback.pushConsoleInfo(str(start_point))
                end_point = geom.interpolate(d)
                # feedback.pushConsoleInfo(str(end_point))
                if feature.geometry().intersects(geom) and not ( feature.geometry().intersects(start_point) or feature.geometry().intersects(end_point)):
                    flag=1
                    break
                    pass
                pass
            if flag==1:
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotSelfIntersect(self, parameters, context, feedback):
        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), QgsWkbTypes.Point, source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            # feedback.pushConsoleInfo(str(feature.id()))
            # feedback.pushConsoleInfo(str(feature.geometry().get().isValid()))
            for error in feature.geometry().validateGeometry():
                if feedback.isCanceled():
                    break
                    pass
                # feedback.pushConsoleInfo(str(error.what()))
                if error.hasWhere() and str(error.what()).find('intersect')>-1:
                    feat=QgsFeature()
                    feat.setFields(source.fields())
                    feat.setGeometry(QgsGeometry.fromPointXY(error.where()))
                    # feedback.pushConsoleInfo(str(error.where()))
                    sink.addFeature(feat, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotSelfOverlap(self, parameters, context, feedback):
        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        if source.wkbType() not in self.lineTypes:
            # feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Line type Source Layer')
            context.setLayersToLoadOnCompletion({})
            return (None, None)
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            segemnts=[]
            if feature.geometry().isMultipart():
                segemnts=self.getMultiLineSeg(feature.geometry())
                pass
            else:
                segemnts = self.getLineSeg(feature.geometry())
                pass
            flag=0
            for i in range(len(segemnts)):
                if feedback.isCanceled():
                    break
                    pass
                for j in range(i+1,len(segemnts)):
                    if feedback.isCanceled():
                        break
                        pass
                    # print(i,j,segemnts[i].overlaps(segemnts[j]) or segemnts[i].isGeosEqual(segemnts[j]))
                    if segemnts[i].overlaps(segemnts[j]) or segemnts[i].isGeosEqual(segemnts[j]):
                        feat = QgsFeature()
                        feat.setFields(source.fields())
                        feat.setAttributes(feature.attributes())
                        feat.setGeometry(segemnts[i])
                        sink.addFeature(feat, QgsFeatureSink.FastInsert)
                        break
                        pass
                    pass
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotOverlap(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        print(source.fields())
        exp = "overlaps(  $geometry , geom_from_wkt( '{geom}')) and $id >{fid}"
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            flag = 0
            geom_wkt = feature.geometry().asWkt()
            req = QgsFeatureRequest().setFilterExpression(exp.format(geom=geom_wkt,fid=feature.id()))
            for feat in source.getFeatures(req):
                if feedback.isCanceled():
                    break
                    pass
                # print(feature.id(),feat.id(),feat.geometry().overlaps(feature.geometry()))
                if feat.geometry().overlaps(feature.geometry()) and feat.id() != feature.id():
                    flag = 1
                    break
                    pass
                pass
            if flag == 1:
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHaveGap(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        self.min_dist =1000
        if source.wkbType() not in self.polygonTypes:
            # feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Polygon type Source Layer')
            return (None, None)
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            geom=feature.geometry()
            if geom.isMultipart():
                geoms=[]
                for geo in geom.asGeometryCollection():
                    ext = geo.get().exteriorRing()
                    line = QgsGeometry.fromWkt(ext.asWkt())
                    polygon = line.convertToType(QgsWkbTypes.PolygonGeometry)
                    geoms.append(polygon)
                    pass
                prgeom=QgsGeometry.unaryUnion(geoms)
                pass
            else:
                ext = geom.get().exteriorRing()
                line = QgsGeometry.fromWkt(ext.asWkt())
                prgeom = line.convertToType(QgsWkbTypes.PolygonGeometry)
                pass
            req = QgsFeatureRequest(feature.geometry().boundingBox())
            for feat in source.getFeatures(req):
                if not (feature.geometry().intersects(feat.geometry())):
                    continue
                if feat.geometry().isMultipart():
                    geoms = []
                    for geo in feat.geometry().asGeometryCollection():
                        ext = geo.get().exteriorRing()
                        line = QgsGeometry.fromWkt(ext.asWkt())
                        polygon = line.convertToType(QgsWkbTypes.PolygonGeometry)
                        geoms.append(polygon)
                        pass
                    secgeom = QgsGeometry.unaryUnion(geoms)
                    pass
                else:
                    ext = feat.geometry().get().exteriorRing()
                    line = QgsGeometry.fromWkt(ext.asWkt())
                    secgeom = line.convertToType(QgsWkbTypes.PolygonGeometry)
                    pass
                union = QgsGeometry.unaryUnion([prgeom, secgeom])
                if not union.isMultipart():
                    try:
                        ext = union.get().exteriorRing()
                        line = QgsGeometry.fromWkt(ext.asWkt())
                        polygon = line.convertToType(QgsWkbTypes.PolygonGeometry)
                        dirt = polygon.difference(union)
                        feat1 = QgsFeature()
                        feat1.setFields(source.fields())
                        feat1.setAttributes(feature.attributes())
                        feat1.setGeometry(dirt)
                        sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                    except Exception as e:
                        print("E1", e)
                        pass
                else:
                    try:
                        # print union.geometry().coordinateSequence()
                        inter = prgeom.intersection(secgeom)
                        if prid == 193:
                            print(inter.exportToWkt())
                        sum = 0

                        if inter.type() == QGis.Point and inter.isMultipart():
                            print("IS Multipart,IS Point")
                            d = inter.geometry()

                            d.dropZValue()
                            inter = QgsGeometry.fromWkt(d.asWkt())
                            intersect = loads(inter.exportToWkt())
                            # print str(intersect.wkt)
                            prpt = []
                            secpt = []
                            coords = []
                            for geom in intersect.geoms:
                                for i, j in geom.coords:
                                    pt = QgsPoint(i, j)
                                    pt2 = QgsPointV2(i, j)
                                    coords.append(pt2.asWkt())
                                    # print QgsGeometry.fromPoint(pt).exportToWkt()
                                    prpt.append(prgeom.closestVertex(pt)[1])
                                    # print prgeom.closestVertex(pt)
                                    secpt.append(secgeom.closestVertex(pt)[1])
                            prpt.sort()
                            secpt.sort()
                            # print prpt
                            # print secpt
                            bound = QgsLineStringV2()
                            d = prgeom.geometry()
                            d.dropZValue()
                            pri = loads(d.asWkt())
                            n = 0
                            # print n
                            if prgeom.type() == QGis.Polygon:
                                line3 = pri.exterior
                            else:
                                line3 = pri
                            points = []
                            for x, y in line3.coords:
                                if n >= prpt[0] and n <= prpt[len(prpt) - 1]:
                                    bound.addVertex(QgsPointV2(x, y))
                                    points.append(QgsPointV2(x, y).asWkt())
                                n = n + 1
                            for pot in coords:
                                if pot not in points:
                                    bound.addVertex(QgsGeometry.fromWkt(pot).geometry())
                            prnew = QgsGeometry.fromWkt(bound.asWkt())
                            bound = QgsLineStringV2()
                            d = secgeom.geometry()
                            d.dropZValue()
                            sec = loads(d.asWkt())
                            n = 0
                            try:
                                if secgeom.type() == QGis.Polygon:
                                    line3 = sec.exterior
                                else:
                                    line3 = sec
                                for x, y in line3.coords:
                                    if n >= secpt[0] and n <= secpt[len(prpt) - 1]:
                                        bound.addVertex(QgsPointV2(x, y))
                                    n = n + 1
                                secnew = QgsGeometry.fromWkt(bound.asWkt())
                                line = prnew.combine(secnew)
                                polygon = line.convertToType(QgsWkbTypes.Polygon)
                                ref = None
                                if (prgeom.type() == QGis.Line):
                                    new = secgeom.geometry()
                                    new.dropZValue()
                                    ref = new.asWkt()
                                elif (secgeom.type() == QGis.Line):
                                    new = prgeom.geometry()
                                    new.dropZValue()
                                    ref = new.asWkt()
                                if ref:

                                    if QgsGeometry.fromWkt(ref).intersection(polygon).exportToWkt() == ref:
                                        continue
                                feat1 = QgsFeature()
                                feat1.setFields(source.fields())
                                feat1.setAttributes(feature.attributes())
                                feat1.setGeometry(polygon)
                                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                                pass
                            except Exception as e:
                                continue

                        elif inter.type() == QGis.Line or inter.exportToWkt().lower().find(
                                "linestring") > -1:

                            print("IS Multipart,IS Line")
                            d = inter.geometry()

                            # if prid==770:
                            #     print inter.type()
                            #     print inter.exportToWkt()

                            try:
                                geom3 = None
                                lines = []
                                if inter.isMultipart():
                                    for i in range(0, d.numGeometries()):
                                        g = d.geometryN(i)
                                        geom2 = QgsGeometry.fromWkt(g.asWkt())
                                        lines.append(geom2)
                                        pass
                                    pass
                                else:
                                    lines.append(inter)
                                    pass
                                # print str(prid)+":"+str(lines)+":"+str(inter.isMultipart())
                                if prgeom.type() == QGis.Polygon:
                                    d = prgeom.geometry()
                                    line2 = QgsGeometry.fromWkt(secgeom.exportToWkt())
                                    poly = loads(d.asWkt())
                                elif secgeom.type() == QGis.Polygon:
                                    d = secgeom.geometry()
                                    line2 = QgsGeometry.fromWkt(prgeom.exportToWkt())
                                    poly = QgsGeometry.fromWkt(d.asWkt())
                                for line in lines:
                                    try:
                                        split = poly.splitGeometry(line.asPolyline(), False)
                                        # if prid == 770 or prid == 336:
                                        #     print split
                                        diff = poly.difference(split[1][0])
                                        geom = QgsGeometry.fromWkt(split[1][0].exportToWkt())
                                        if geom.area() > diff.area() and str(
                                                diff.exportToWkt()) != "GeometryCollection ()":
                                            geom = QgsGeometry.fromWkt(diff.exportToWkt())
                                            pass
                                    except Exception as e:
                                        split = poly.splitGeometry(line2.asPolyline(), False)
                                        geom3 = QgsGeometry.fromWkt(poly.exportToWkt())
                                        for p in split[1]:
                                            try:
                                                diff = poly.difference(p)
                                                geom = QgsGeometry.fromWkt(p.exportToWkt())
                                                if geom.area() > diff.area() and str(
                                                        diff.exportToWkt()) != "GeometryCollection ()":
                                                    geom = QgsGeometry.fromWkt(diff.exportToWkt())
                                                    pass
                                                geom3 = geom3.difference(geom)
                                                feat1 = QgsFeature()
                                                feat1.setFields(source.fields())
                                                feat1.setAttributes(feature.attributes())
                                                feat1.setGeometry(geom)
                                                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                                                pass

                                            except Exception as e:
                                                # print split
                                                # print e
                                                pass
                                        break
                                    pass

                                    geom3 = poly.difference(geom)
                                    fet.setGeometry(geom)
                                    # print "geom_1", geom.asPolygon()
                                    # print  QgsGeometry.fromWkt(diff.asWkt()).exportToWkt()
                                    if geom.area() <= self.min_dist:
                                        fet.setAttribute(0, prid)
                                        fet.setAttribute(1, secid)
                                        fet.setAttribute(2, geom.area())
                                        # fet.setAttribute(3, self.pLayer.name() + ";" + self.secLayer.name())
                                        if str(geom.exportToWkt()) != "GeometryCollection ()":

                                            pr.addFeatures([fet])
                                            self.err.append(fet)
                                            pass
                                diff = line2.difference(poly)

                                lines = []
                                if diff.isMultipart():
                                    d = diff.geometry()
                                    for i in range(0, d.numGeometries()):
                                        g = d.geometryN(i)
                                        geom2 = QgsGeometry.fromWkt(g.asWkt())
                                        lines.append(geom2)
                                        pass
                                    pass
                                else:
                                    lines.append(diff)
                                    pass

                                for line in lines:
                                    # intersect = QgsGeometry.fromWkt(poly.geometry().boundary().asWkt()).intersection(line)
                                    # if intersect.type() == QGis.Point and intersect.isMultipart() == False:
                                    #     if prid == 337:
                                    #         print str(prid) + ":" + intersect.exportToWkt()
                                    #     continue
                                    #     pass

                                    if (line.convertToType(QgsWkbTypes.Polygon)):
                                        geom = line.convertToType(QgsWkbTypes.Polygon)
                                        # print geom.exportToWkt()
                                        fet.setGeometry(geom)
                                        # print "geom_2", geom.asPolygon()
                                        if geom.area() <= self.min_dist:
                                            fet.setAttribute(0, prid)
                                            fet.setAttribute(1, secid)
                                            fet.setAttribute(2, geom.area())
                                            # fet.setAttribute(3,
                                            #                  self.pLayer.name() + ";" + self.secLayer.name())
                                            section = geom.intersection(poly)
                                            if section.type() == QGis.Point and section.isMultipart() == False:
                                                continue
                                            if str(geom.exportToWkt()) != "GeometryCollection ()":
                                                #pr.addFeatures([fet])

                                                self.err.append(fet)
                                                pass
                                    else:
                                        continue
                                        pass

                                    pass

                                pass
                            except Exception as e:
                                continue
                                pass
                            pass

                    except Exception as e:
                        continue
                        pass
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHaveDangle(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(),  QgsWkbTypes.Point, source.sourceCrs())
        if source.wkbType() not in self.lineTypes:
            # feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Line type Source Layer')
            return (None, None)
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        exp = "intersects(  $geometry ,  start_point( geom_from_wkt( '{geom}'))) and intersects(  $geometry ,  end_point( geom_from_wkt( '{geom}'))) and $id >{fid}"
        features = source.getFeatures()
        self.dist = 0.0001
        da = QgsDistanceArea()
        da.setSourceCrs(QgsCoordinateReferenceSystem(3857), QgsCoordinateTransformContext())
        if source.sourceCrs().authid() not in (3857, '3857'):
            self.dist = da.convertLengthMeasurement(self.dist, source.sourceCrs().mapUnits())
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            geom_wkt=feature.geometry().asWkt()
            geom=feature.geometry()
            d = geom.length()
            # print(self.dist)
            start_point1 = geom.interpolate(0)
            st_point = loads(start_point1.asWkt())
            st_buffer = st_point.buffer(self.dist)
            start_point = QgsGeometry.fromWkt(st_buffer.wkt)
            # feedback.pushConsoleInfo(str(start_point))
            end_point1 = geom.interpolate(d)
            ed_point = loads(end_point1.asWkt())
            ed_buffer = ed_point.buffer(self.dist)
            end_point = QgsGeometry.fromWkt(ed_buffer.wkt)
            # req=QgsFeatureRequest().setFilterExpression(exp.format(fid=feature.id(),geom=geom_wkt))
            req = QgsFeatureRequest(feature.geometry().boundingBox())
            flag1=0
            flag2 = 0
            for feat in source.getFeatures(req):
                if feedback.isCanceled():
                    break
                    pass
                if feat.id()==feature.id():
                    continue
                # feedback.pushConsoleInfo(str(end_point))
                # print('start_point',feat.geometry().intersects(start_point), feat.geometry().distance(start_point))
                # print('end_point',feat.geometry().intersects(end_point),feat.geometry().distance(end_point))
                if ( feat.geometry().intersects(start_point)):
                    # print(feat.id(),feature.id(),'start Point')
                    flag1=1
                    pass
                if (feat.geometry().intersects(end_point)):
                    # print(feat.id(), feature.id(), 'end Point')
                    flag2=1
                    pass
                pass
            # print(flag1,flag2)
            if flag1==0:
                feat1 = QgsFeature()
                feat1.setFields(source.fields())
                feat1.setAttributes(feature.attributes())
                feat1.setGeometry(start_point1)
                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                pass
            if flag2==0:
                feat1 = QgsFeature()
                feat1.setFields(source.fields())
                feat1.setAttributes(feature.attributes())
                feat1.setGeometry(end_point1)
                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHavePseudoNode(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), QgsWkbTypes.Point, source.sourceCrs())
        self.dist=0.0001
        da = QgsDistanceArea()
        da.setSourceCrs(QgsCoordinateReferenceSystem(3857),QgsCoordinateTransformContext())
        if source.sourceCrs().authid()not in (3857,'3857'):
            self.dist = da.convertLengthMeasurement(self.dist, source.sourceCrs().mapUnits())
        # print (self.dist)
        if source.wkbType() not in self.lineTypes:
            # feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Line type Source Layer')
            return (None, None)
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        exp = "(intersects(   start_point( $geometry) , geom_from_wkt( '{st_geom}')) " \
              "or intersects(   end_point( $geometry ), geom_from_wkt( '{end_geom}')))) " \
              "and $id >{fid}"
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            # print(feature.id())
            geom=feature.geometry()
            d = geom.length()
            multiline = []
            if geom.isMultipart():
                multiline=multiline+geom.asMultiPolyline()
                pass
            else:
                multiline.append(geom.asPolyline())
                pass
            start_point1 = geom.interpolate(0)
            st_point = loads(start_point1.asWkt())
            st_buffer = st_point.buffer(self.dist)
            start_point = QgsGeometry.fromWkt(st_buffer.wkt)
            # feedback.pushConsoleInfo(str(start_point))
            end_point1 = geom.interpolate(d)
            ed_point = loads(end_point1.asWkt())
            ed_buffer = ed_point.buffer(self.dist)
            end_point = QgsGeometry.fromWkt(ed_buffer.wkt)
            # req = QgsFeatureRequest().setFilterExpression(exp.format(fid=feature.id(), st_geom=start_point.asWkt(), end_geom=end_point.asWkt()))
            req = QgsFeatureRequest(feature.geometry().boundingBox())
            flag1 = 0
            flag2 = 0
            for feat in source.getFeatures(req):
                if feedback.isCanceled():
                    break
                    pass
                if  feature.id()>=feat.id():
                    continue
                    pass
                geom2 = feat.geometry()
                d2 = geom2.length()
                if geom2.isMultipart():
                    multiline = multiline+geom2.asMultiPolyline()
                    pass
                else:
                    multiline.append(geom2.asPolyline())
                    pass
                start_point2 = geom2.interpolate(0)
                end_point2 = geom2.interpolate(d2)
                geoms=[]
                geoms.append(geom)
                geoms.append(geom2)
                feedback.pushConsoleInfo(
                    'feature(1) id : {fid1},feature(2) id : {fid2}'.format(fid1=feature.id(), fid2=feat.id()))

                feedback.pushConsoleInfo(
                    'START Distance : {fid1},END Distance: {fid2}'.format(fid1=start_point.distance(start_point2), fid2=end_point.distance(end_point2)))
                if (start_point.intersects(start_point2) or abs(start_point.distance(start_point2))<=self.dist):
                    flag1 = flag1+1
                    pass
                if (end_point.intersects(end_point2) or abs(end_point.distance(end_point2))<=self.dist):
                    flag2 = flag2+ 1
                    pass
                pass

            mergeLine = QgsGeometry.fromMultiPolylineXY(multiline)
            geom3=mergeLine.mergeLines()
            feedback.pushConsoleInfo('Flag 1 : {fid1},Flag2: {fid2}'.format(fid1=flag1, fid2=flag2))

            if flag1==1 and not geom3.isMultipart():
                feat1 = QgsFeature()
                feat1.setFields(source.fields())
                feat1.setAttributes(feature.attributes())
                feat1.setGeometry(start_point1)
                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                pass
            if flag2==1 and not geom3.isMultipart():
                feat1 = QgsFeature()
                feat1.setFields(source.fields())
                feat1.setAttributes(feature.attributes())
                feat1.setGeometry(end_point1)
                sink.addFeature(feat1, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHaveDuplicate(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        exp = "$id >{fid}"
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            flag = 0
            geom_wkt = feature.geometry().asWkt()
            req = QgsFeatureRequest().setFilterExpression(exp.format(fid=feature.id()))
            for feat in source.getFeatures(req):
                if feedback.isCanceled():
                    break
                    pass
                # print(feature.id(),feat.id(),feat.geometry().overlaps(feature.geometry()))
                if feat.geometry().isGeosEqual(feature.geometry()) and feat.id() > feature.id():
                    flag = 1
                    break
                    pass
                pass
            if flag == 1:
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHaveInvalid(self, parameters, context, feedback):
        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(),source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            for error in feature.geometry().validateGeometry():
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                break
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def mustNotHaveMutipart(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(),source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            geom = feature.geometry()
            if geom.isMultipart() and len(geom.asGeometryCollection())>1:
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                pass
            feedback.setProgress(int(current * total))
            pass
        return (sink, dest_id)
        pass

    def getLineSeg(self,geom):
        segemnts = []
        if geom.isEmpty():
            return segemnts
        coords= geom.asPolyline()
        for i in range(len(coords)-1):
            seg=[coords[i],coords[i+1]]
            segemnts.append(QgsGeometry.fromPolylineXY(seg))
            pass
        return segemnts
        pass

    def getMultiLineSeg(self,geom):
        segemnts = []
        if geom.isEmpty():
            return segemnts
        coordslist = geom.asMultiPolyline()
        for coords in coordslist:
            for i in range(len(coords)-1):
                seg = [coords[i] , coords[i + 1]]
                segemnts.append(QgsGeometry.fromPolylineXY(seg))
                pass
            pass
        return segemnts
        pass

    def mustEdgematchwith(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        target = self.parameterAsSource(parameters, self.INPUT, context)
        #bufferdistance = self.parameterAsDouble(parameters, self.INPUT_BUFFERDIST, context)
        if (target.wkbType() not in self.polygonTypes) and (target.wkbType() not in self.lineTypes):
            # feedback.pushConsoleInfo(str(source.wkbType()))
            feedback.pushConsoleInfo('Requires Polygon type Target Layer')
            return (None, None)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, source.fields(), source.wkbType(), source.sourceCrs())
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()
        bufferFeature = QgsFeature(source.fields())
        exp = "buffer($geometry, distance[, segments=8])"
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break
                pass
            if feature.geometry().isEmpty():
                continue
            # Distance
            self.dist = 0.01
            da = QgsDistanceArea()
            da.setSourceCrs(QgsCoordinateReferenceSystem(3857), QgsCoordinateTransformContext())
            if source.sourceCrs().authid() not in (3857, '3857'):
                self.dist = da.convertLengthMeasurement(self.dist, source.sourceCrs().mapUnits())
            geom = feature.geometry()
            buffer = geom.buffer(self.dist, 8)
            bufferFeature.setGeometry(geom)
            bb = QgsFeatureRequest(buffer.boundingBox())
            refFeatures = target.getFeatures(bb)
            for refFeature in refFeatures:
                if feature["sub_class"] == refFeature["sub_class"] and (feature.id() != refFeature.id()) and (
                        feature.id() < refFeature.id()):
                    if feature.geometry().distance(refFeature.geometry()) <= self.dist:
                        #print(feature.id())
                        #print(refFeature.id())
                        if feature.geometry().intersects(refFeature.geometry()) and bufferFeature.geometry().intersects(
                                refFeature.geometry()):
                            sink.addFeature(feature, QgsFeatureSink.FastInsert)
                        #     pass
                        # else:
                        #     sink.addFeature(feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int(current * total))
        return (sink, dest_id)