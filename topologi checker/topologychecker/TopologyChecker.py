# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Topologychecker
                                 A QGIS plugin
 Performs topology checks
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-15
        git sha              : $Format:%H$
        copyright            : (C) 2021 by TopologyChecKer
        email                : TopologyChecKer
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *

from qgis.gui import *
from qgis.core import *


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from . TopologyChecker_dialog import TopologycheckerDialog
from .TopologyChecker_engine import RandomIntegerSumTask
import os.path
import processing
import csv
from datetime import datetime


class Topologychecker:
    """QGIS Plugin Implementation."""
    # suffix = 'vw_'
    suffix = ''
    global fileflag
    fileflag= False
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Topologychecker_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Topology ChecKer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Topologychecker', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ TopologyChecKer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Topology ChecKer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Topology ChecKer'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = TopologycheckerDialog()
            pass
        self.dlg.show()
        self.dlg.pb1.clicked.connect(self.RunLocal)
        self.dlg.pb3.clicked.connect(self.RunGDB)
        self.dlg.pb2.clicked.connect(self.Cancel)

    def RunGDB(self):
        self.dlg.close()
        if self.dlg.lineEdit.text() == '' :
            QMessageBox.information(None, "GDB_name",'Please enter some values to GDB_name')
            return
        else:
            self.suffix= self.dlg.lineEdit.text()+' '
            from processing.tools import dataobjects
            context = dataobjects.createContext()
            context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)

            rules1 = ['Must Not Intersect or touch interior','Must Not Self-Intersect','Must Not Self-Overlap'
                ,'Must Not Overlap','Must Not Have Gap'
                ,'Must Not Have Dangle','Must Not Have Pseudo Node',
                 'Must Not Have Duplicate Feature','Must Not Have Invalid Geometry','Must Not Have Invalid Geometry','Merge with same Sub class']

            comments1 = ['Must Not Intersect or touch interior', 'Must Not Self-Intersect', 'Must Not Self-Overlap'
                , 'Must Not Overlap', 'Must Not Have Gap'
                , 'Must Not Have Dangle', 'Must Not Have Pseudo Node',
                      'Must Not Have Duplicate Feature', 'Must Not Have Invalid Geometry', 'Must Not Have Invalid Geometry','Merge with same Sub class']

            rules2 = ['Must Be Covered By Boundary Of','Must Cover Each Other','Must Be properly inside',
                      'Must Be Covered By End Point Of','Must Be Covered By Feature Class Of', 'Must Be Inside'
                ,'Must Not Overlap With','Must Overlap With', 'Must Be Snapped To']

            comments2 = ['Must Be Covered By Boundary Of', 'Must Cover Each Other', 'Must Be properly inside',
                      'Must Be Covered By End Point Of', 'Must Be Covered By Feature Class Of', 'Must Be Inside'
                , 'Should Not Be Overlap On', 'Must Overlap With', 'Must Be Snapped To']
            rules3 = ['Must Edge match with']

            comments3 = ['Must Edge match with']

            algo1='ptp_tools:topology_checker'
            algo2='ptp_tools:topology_checker_v2'
            algo3 = 'ptp_tools:topology_checker_v2'

            path=os.path.join(self.plugin_dir,'data','Topology_Rules_Wonobo.xls')
            #print(path)

            layer = QgsVectorLayer(path, 'test', 'ogr')
            # QgsProject.instance().addMapLayer(layer)
            fields=['Source-Layers','Topology_rules','Target-Layers']
            count=0
            result=[]
            algos=[]
            for feat in layer.getFeatures():
                #print(count+1, feat[fields[0]], feat[fields[1]], feat[fields[2]])
                if str(feat[fields[1]]).strip() in rules1:
                    comment=comments1[rules1.index(str(feat[fields[1]]).strip())]
                    if str(feat[fields[0]]).lower()=='all layers':
                        inputLayers=self.getAllLayers(None)
                        pass
                    elif str(feat[fields[0]]).lower()=='all polygonal layers':
                        inputLayers=self.getAllPolygonalLayers(None)
                        pass
                    elif str(feat[fields[0]]).lower()=='all linear layers':
                        inputLayers=self.getAllLinearLayers(None)
                        pass
                    elif str(feat[fields[0]]).lower()=='all point layers':
                        inputLayers=self.getAllPointLayers(None)
                        pass
                    else:
                        inputLayers = QgsProject.instance().mapLayersByName(self.suffix + str(feat[fields[0]]).lower())
                        #print(inputLayers)
                        pass
                    if len(inputLayers)==0:
                        #print(self.suffix + str(feat[fields[0]]).lower())
                        continue
                        pass
                    for inputLayer in inputLayers:
                        config = {'INPUT': inputLayer.source(),
                                  'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE': rules1.index(str(feat[fields[1]]).strip())}
                        # output = processing.run(algo1, config, context=context)
                        idx=inputLayer.dataProvider().fieldNameIndex('prodgrid')
                        grids=inputLayer.uniqueValues(idx)
                        algos.append([inputLayer.name(), comment, feat[fields[2]],algo1, config,context,grids])
                        # if output['OUTPUT']:
                        #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                        #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                        #     pass
                        # print(output)
                        pass
                    pass
                elif str(feat[fields[1]]).strip() in rules2:
                    comment = comments2[rules2.index(str(feat[fields[1]]).strip())]
                    # print(str(feat[fields[0]]).lower(),str(feat[fields[0]]).lower()=='all')
                    if str(feat[fields[0]]).lower()=='all layers':
                        inputLayers=self.getAllLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all polygonal layers':
                        inputLayers=self.getAllPolygonalLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all linear layers':
                        inputLayers=self.getAllLinearLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all point layers':
                        inputLayers=self.getAllPointLayers(feat[fields[2]])
                        pass
                    else:
                        inputLayers = QgsProject.instance().mapLayersByName(self.suffix + str(feat[fields[0]]).lower())
                        pass
                    targetLayers = QgsProject.instance().mapLayersByName( self.suffix + str(feat[fields[2]]).lower())
                    if len(inputLayers)==0 or len(targetLayers)==0:
                        # print(self.suffix + str(feat[fields[0]]).lower()+':'+self.suffix + str(feat[fields[2]]).lower())
                        continue
                        pass
                    for inputLayer in inputLayers:
                        for targetLayer in targetLayers:
                            config = {'INPUT': inputLayer.source(),
                                      'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE':  rules2.index(str(feat[fields[1]]).strip()),
                                      'TARGET': targetLayer.source()}
                            # output=processing.run(algo2,config,context=context)
                            idx = inputLayer.dataProvider().fieldNameIndex('prodgrid')
                            grids = inputLayer.uniqueValues(idx)
                            algos.append([inputLayer.name(), comment, targetLayer.name(),algo2,config, context,grids])
                            # if output['OUTPUT']:
                            #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                            #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                            #     pass
                            # print(output)
                            pass
                        pass
                    pass
                elif str(feat[fields[1]]).strip() in rules3:
                    comment = comments3[rules3.index(str(feat[fields[1]]).strip())]
                    # print(str(feat[fields[0]]).lower(),str(feat[fields[0]]).lower()=='all')
                    if str(feat[fields[0]]).lower()=='all layers':
                        inputLayers=self.getAllLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all polygonal layers':
                        inputLayers=self.getAllPolygonalLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all linear layers':
                        inputLayers=self.getAllLinearLayers(feat[fields[2]])
                        pass
                    elif str(feat[fields[0]]).lower()=='all point layers':
                        inputLayers=self.getAllPointLayers(feat[fields[2]])
                        pass
                    else:
                        inputLayers = QgsProject.instance().mapLayersByName(self.suffix + str(feat[fields[0]]).lower())
                        pass

                    if len(inputLayers)==0 :
                        #print(self.suffix + str(feat[fields[0]]).lower()+':'+self.suffix + str(feat[fields[2]]).lower())
                        continue
                        pass
                    for inputLayer in inputLayers:
                        targetLayers = QgsProject.instance().mapLayersByName(self.suffix + "ref_" + str(inputLayer.name()).lower())
                        if len(targetLayers)==0:
                            continue
                            pass
                        for targetLayer in targetLayers:
                            config = {'INPUT': inputLayer.source(),
                                      'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE':  rules3.index(str(feat[fields[1]]).strip()) +  len(rules2),
                                      'TARGET': targetLayer.source()}
                            # output=processing.run(algo2,config,context=context)
                            idx = inputLayer.dataProvider().fieldNameIndex('prodgrid')
                            grids = inputLayer.uniqueValues(idx)
                            algos.append([inputLayer.name(), comment, targetLayer.name(),algo3,config, context,grids])
                            # if output['OUTPUT']:
                            #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                            #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                            #     pass
                            # print(output)
                            pass
                        pass
                    pass
                else:
                    pass
                    #print(feat[fields[1]])
                count+=1
                pass

            #print(algos)

            if len(algos)>0:
                globals()['Topology Checker'] = RandomIntegerSumTask('Perform Topology Check',algos, self)
                # globals()['Topology Checker'].progressChanged.connect(self.dlg.progressBar.setValue)
                QgsApplication.taskManager().addTask(globals()['Topology Checker'])
                pass
            # errCount=self.loadResult(result)
            #         # QMessageBox.information(None, "Topology Check Done",
            #         #                         str(errCount)+" Errors Found")
            pass

    def RunLocal(self):
        self.dlg.close()
        from processing.tools import dataobjects
        context = dataobjects.createContext()
        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)

        rules1 = ['Must Not Intersect or touch interior','Must Not Self-Intersect','Must Not Self-Overlap'
            ,'Must Not Overlap','Must Not Have Gap'
            ,'Must Not Have Dangle','Must Not Have Pseudo Node',
             'Must Not Have Duplicate Feature','Must Not Have Invalid Geometry','Must Not Have Invalid Geometry','Merge with same Sub class']

        comments1 = ['Must Not Intersect or touch interior', 'Must Not Self-Intersect', 'Must Not Self-Overlap'
            , 'Must Not Overlap', 'Must Not Have Gap'
            , 'Must Not Have Dangle', 'Must Not Have Pseudo Node',
                  'Must Not Have Duplicate Feature', 'Must Not Have Invalid Geometry', 'Must Not Have Invalid Geometry','Merge with same Sub class']

        rules2 = ['Must Be Covered By Boundary Of','Must Cover Each Other','Must Be properly inside',
                  'Must Be Covered By End Point Of','Must Be Covered By Feature Class Of', 'Must Be Inside'
            ,'Must Not Overlap With','Must Overlap With', 'Must Be Snapped To']

        comments2 = ['Must Be Covered By Boundary Of', 'Must Cover Each Other', 'Must Be properly inside',
                  'Must Be Covered By End Point Of', 'Must Be Covered By Feature Class Of', 'Must Be Inside'
            , 'Should Not Be Overlap On', 'Must Overlap With', 'Must Be Snapped To']
        rules3 = ['Must Edge match with']

        comments3 = ['Must Edge match with']

        algo1='ptp_tools:topology_checker'
        algo2='ptp_tools:topology_checker_v2'
        algo3 = 'ptp_tools:topology_checker_v2'

        path=os.path.join(self.plugin_dir,'data','Topology_Rules_Wonobo.xls')
        #print(path)

        layer = QgsVectorLayer(path, 'test', 'ogr')
        #QgsProject.instance().addMapLayer(layer)
        fields=['Source-Layers','Topology_rules','Target-Layers']
        count=0
        result=[]
        algos=[]
        for feat in layer.getFeatures():
            #print(count+1, feat[fields[0]], feat[fields[1]], feat[fields[2]])
            if str(feat[fields[1]]).strip() in rules1:
                #print(str(feat[fields[0]]).strip())
                comment=comments1[rules1.index(str(feat[fields[1]]).strip())]
                if str(feat[fields[0]]).lower()=='all layers':
                    inputLayers=self.getAllLayers(None)
                    pass
                elif str(feat[fields[0]]).lower()=='all polygonal layers':
                    inputLayers=self.getAllPolygonalLayers(None)
                    #print(inputLayers)
                    pass
                elif str(feat[fields[0]]).lower()=='all linear layers':
                    inputLayers=self.getAllLinearLayers(None)
                    pass
                elif str(feat[fields[0]]).lower()=='all point layers':
                    inputLayers=self.getAllPointLayers(None)
                    pass
                else:
                    inputLayers = QgsProject.instance().mapLayersByName(str(feat[fields[0]]).lower())
                    #print(inputLayers)
                    pass
                if len(inputLayers)==0:
                    #print(self.suffix + str(feat[fields[0]]).lower())
                    continue
                    pass
                for inputLayer in inputLayers:
                    config = {'INPUT': inputLayer.source(),
                              'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE': rules1.index(str(feat[fields[1]]).strip())}
                    # output = processing.run(algo1, config, context=context)
                    idx=inputLayer.dataProvider().fieldNameIndex('prodgrid')
                    grids=inputLayer.uniqueValues(idx)
                    algos.append([inputLayer.name(), comment, feat[fields[2]],algo1, config,context,grids])
                    # if output['OUTPUT']:
                    #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                    #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                    #     pass
                    # print(output)
                    pass
                pass
            elif str(feat[fields[1]]).strip() in rules2:
                comment = comments2[rules2.index(str(feat[fields[1]]).strip())]
                # print(str(feat[fields[0]]).lower(),str(feat[fields[0]]).lower()=='all')
                if str(feat[fields[0]]).lower()=='all layers':
                    inputLayers=self.getAllLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all polygonal layers':
                    inputLayers=self.getAllPolygonalLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all linear layers':
                    inputLayers=self.getAllLinearLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all point layers':
                    inputLayers=self.getAllPointLayers(feat[fields[2]])
                    pass
                else:
                    inputLayers = QgsProject.instance().mapLayersByName(str(feat[fields[0]]).lower())
                    #print(inputLayers)
                    pass
                targetLayers = QgsProject.instance().mapLayersByName(str(feat[fields[2]]).lower())
                #print(targetLayers)
                if len(inputLayers)==0 or len(targetLayers)==0:
                    # print(self.suffix + str(feat[fields[0]]).lower()+':'+self.suffix + str(feat[fields[2]]).lower())
                    continue
                    pass
                #print(inputLayers)
                for inputLayer in inputLayers:
                    for targetLayer in targetLayers:
                        config = {'INPUT': inputLayer.source(),
                                  'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE':  rules2.index(str(feat[fields[1]]).strip()),
                                  'TARGET': targetLayer.source()}
                        # output=processing.run(algo2,config,context=context)
                        idx = inputLayer.dataProvider().fieldNameIndex('prodgrid')
                        grids = inputLayer.uniqueValues(idx)
                        algos.append([inputLayer.name(), comment, targetLayer.name(),algo2,config, context,grids])
                        # if output['OUTPUT']:
                        #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                        #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                        #     pass
                        # print(output)
                        pass
                    pass
                pass
            elif str(feat[fields[1]]).strip() in rules3:
                comment = comments3[rules3.index(str(feat[fields[1]]).strip())]
                # print(str(feat[fields[0]]).lower(),str(feat[fields[0]]).lower()=='all')
                if str(feat[fields[0]]).lower()=='all layers':
                    inputLayers=self.getAllLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all polygonal layers':
                    inputLayers=self.getAllPolygonalLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all linear layers':
                    inputLayers=self.getAllLinearLayers(feat[fields[2]])
                    pass
                elif str(feat[fields[0]]).lower()=='all point layers':
                    inputLayers=self.getAllPointLayers(feat[fields[2]])
                    pass
                else:
                    inputLayers = QgsProject.instance().mapLayersByName(str(feat[fields[0]]).lower())
                    pass

                if len(inputLayers)==0 :
                    #print(self.suffix + str(feat[fields[0]]).lower()+':'+self.suffix + str(feat[fields[2]]).lower())
                    continue
                    pass
                for inputLayer in inputLayers:
                    targetLayers = QgsProject.instance().mapLayersByName(self.suffix + "ref_" + str(inputLayer.name()).lower())
                    if len(targetLayers)==0:
                        continue
                        pass
                    for targetLayer in targetLayers:
                        config = {'INPUT': inputLayer.source(),
                                  'OUTPUT': 'TEMPORARY_OUTPUT', 'RULE':  rules3.index(str(feat[fields[1]]).strip()) +  len(rules2),
                                  'TARGET': targetLayer.source()}
                        # output=processing.run(algo2,config,context=context)
                        idx = inputLayer.dataProvider().fieldNameIndex('prodgrid')
                        grids = inputLayer.uniqueValues(idx)
                        algos.append([inputLayer.name(), comment, targetLayer.name(),algo3,config, context,grids])
                        # if output['OUTPUT']:
                        #     result.append([feat[fields[0]], feat[fields[1]], feat[fields[2]], output['OUTPUT']])
                        #     # QgsProject.instance().addMapLayer(output['OUTPUT'])
                        #     pass
                        # print(output)
                        pass
                    pass
                pass
            else:
                pass
                #print(feat[fields[1]])
            count+=1
            pass

        #print(algos)

        if len(algos)>0:
            globals()['Topology Checker'] = RandomIntegerSumTask('Perform Topology Check',algos, self)
            # globals()['Topology Checker'].progressChanged.connect(self.dlg.progressBar.setValue)
            QgsApplication.taskManager().addTask(globals()['Topology Checker'])
            pass
        # errCount=self.loadResult(result)
        #         # QMessageBox.information(None, "Topology Check Done",
        #         #                         str(errCount)+" Errors Found")
        pass
    def Cancel(self):
        self.dlg.close()

    def done(self,errCount):
        QMessageBox.information(None, "Topology Check Done",
                                str(errCount) + " Errors Found")
        pass

    def getAllLayers(self,targetLayer):
        layerlistpath = os.path.join(self.plugin_dir, 'data', 'Total_Layerlist.xls')
        # print(layerlistpath)
        layer = QgsVectorLayer(layerlistpath, 'layerlist', 'ogr')
        # QgsProject.instance().addMapLayer(layer)
        fields = ['All-Layers','Line-Layers','Polygon-Layers']
        layers = []
        for feat in layer.getFeatures():
            layers.append(str(feat[fields[0]]).strip())
        #layers=['Administrative_Boundaries','ATM_And_Meteorological_Station','Bridges','Building','Bus_Stop','Cadastral','Communication_Point','Community_Toilet_Point','Contour_Line','Fire_Station_Point','Flyovers','Garbage_Collection_Point','Gas_Distribution_Network_Line','Gas_Distribution_Network_Point','Ground_Control_Points','Hazard_Prone_Areas','Landfill_Site_And_Dumping_Yard','Land_Use_Land_Cover','Land_Use_Land_Cover_Point','Modification','Municipal_Boundaries','Other_Boundaries','Other_Boundaries_Line','Other_Grid_Point','Other_Height_Restriction','Planning_Boundaries','Power_Supply_Network_Line','Power_Supply_Netwotk_Points','Rail_Line','Rail_Polygon','Reservation','Road_Line','Road_Polygon','Sewerage_Network_Line','Sewerage_Network_Points','Slum','Slum_Point','Storm_Water_Drainage_Network_Line','Storm_Water_Drainage_Network_Points','Tree','Water_Bodies_Line','Water_Bodies_Polygon','Water_Supply_Network_Line','Water_Supply_Network_Points']
        inputLayer=[]
        for layer in layers:
            #print(layer)
            if layer == targetLayer:
                continue
                pass
            # print (layer)
            inputLayer = inputLayer+QgsProject.instance().mapLayersByName(self.suffix + str(layer).lower())
            pass
        #print(inputLayer)
        return inputLayer
        pass

    def getAllPolygonalLayers(self,targetLayer):
        layerlistpath = os.path.join(self.plugin_dir, 'data', 'Total_Layerlist.xls')
        layer = QgsVectorLayer(layerlistpath, 'layerlist', 'ogr')
        # QgsProject.instance().addMapLayer(layer)
        fields = ['All-Layers', 'Line-Layers', 'Polygon-Layers']
        layers = []
        for feat in layer.getFeatures():
            layers.append(str(feat[fields[2]]).strip())
        inputLayer=[]
        for layer in layers:
            if layer == targetLayer:
                #print("rrr",layer)
                continue
                pass
            #print (layer)
            inputLayer = inputLayer+QgsProject.instance().mapLayersByName(self.suffix + str(layer).lower())
            pass
        #print(inputLayer)
        return inputLayer
        pass

    def getAllLinearLayers(self,targetLayer):
        layerlistpath = os.path.join(self.plugin_dir, 'data', 'Total_Layerlist.xls')
        layer = QgsVectorLayer(layerlistpath, 'layerlist', 'ogr')
        # QgsProject.instance().addMapLayer(layer)
        fields = ['All-Layers', 'Line-Layers', 'Polygon-Layers']
        layers = []
        for feat in layer.getFeatures():
            layers.append(str(feat[fields[1]]).strip())
        #layers=["bridges","contour_line","flyovers","gas_distribution_network_line","other_boundaries_line","power_supply_network_line","rail_line","road_line","sewerage_network_line","storm_water_drainage_network_line","water_bodies_line","water_supply_network_line"]
        inputLayer=[]
        for layer in layers:
            if layer == targetLayer:
                continue
                pass
            # print (layer)
            inputLayer = inputLayer+QgsProject.instance().mapLayersByName(self.suffix + str(layer).lower())
            pass
        # print(inputLayer)
        return inputLayer
        pass

    def getAllPointLayers(self,targetLayer):
        layers=["atm_and_meteorological_station","bus_stop","communication_point","community_toilet_point","fire_station_point","garbage_collection_point","gas_distribution_network_point","ground_control_points","land_use_land_cover_point","landfill_site_and_dumping_yard","other_grid_point","power_supply_netwotk_points","sewerage_network_points","slum_point","storm_water_drainage_network_points","tree","water_supply_network_points"]
        inputLayer=[]
        for layer in layers:
            if layer == targetLayer:
                continue
                pass
            # print (layer)
            inputLayer = inputLayer+QgsProject.instance().mapLayersByName(self.suffix + str(layer).lower())
            pass
        # print(inputLayer)
        return inputLayer
        pass

    def loadResult(self,results):
        self.loadData()
        if len(self.data.keys()) == 0:
            return
        vl_point = QgsVectorLayer("Point?crs=epsg:3857", "Point Errors", "memory")
        pr_point = vl_point.dataProvider()
        pr_point.addAttributes([
            QgsField("Input Layer", QVariant.String),
            QgsField("Rule", QVariant.String),
            QgsField("Target Layer", QVariant.String)])
        vl_point.updateFields()
        vl_point.startEditing()

        vl_line = QgsVectorLayer("LineString?crs=epsg:3857", "Line Errors", "memory")
        pr_line = vl_line.dataProvider()
        pr_line.addAttributes([
            QgsField("Input Layer", QVariant.String),
            QgsField("Rule", QVariant.String),
            QgsField("Target Layer", QVariant.String)])
        vl_line.updateFields()
        vl_line.startEditing()

        vl_polygon = QgsVectorLayer("Polygon?crs=epsg:3857", "Polygon Errors", "memory")
        pr_polygon = vl_polygon.dataProvider()
        pr_polygon.addAttributes([
            QgsField("Input Layer", QVariant.String),
            QgsField("Rule", QVariant.String),
            QgsField("Target Layer", QVariant.String)])
        vl_polygon.updateFields()
        vl_polygon.startEditing()

        self.fileflag = False
        self.createNewfile()
        self.createLayerLog()
        for result in results:
            input=result[0]
            rule = result[1]
            target = result[2]
            output = result[3]
            if output.geometryType() == QgsWkbTypes.PointGeometry:
                if self.fileflag == True:
                    layerfeatcount=self.layercount(input)
                    layererrorcount=output.featureCount()
                    errortype="PointType"
                    self.addFeatures(input, rule, target, output, pr_point,layerfeatcount,layererrorcount,errortype)
                    self.addError(input, rule, target, output, 0)
                    pass
                else:
                    self.createNewfile()
                    pass
            elif output.geometryType() == QgsWkbTypes.LineGeometry:
                if self.fileflag == True:
                    layerfeatcount=self.layercount(input)
                    layererrorcount=output.featureCount()
                    errortype="LineType"
                    self.addFeatures(input, rule, target, output, pr_line,layerfeatcount,layererrorcount,errortype)
                    self.addError(input, rule, target, output, 1)
                    pass
                else:
                    self.createNewfile()
                    pass
            elif output.geometryType() == QgsWkbTypes.PolygonGeometry:
                if self.fileflag == True:
                    layerfeatcount = self.layercount(input)
                    layererrorcount = output.featureCount()
                    errortype = "PolygonType"
                    self.addFeatures(input, rule, target, output, pr_polygon,layerfeatcount,layererrorcount,errortype)
                    self.addError(input, rule, target, output, 2)
                    pass
                else:
                    self.createNewfile()
                    pass
            pass

        vl_point.commitChanges()
        vl_line.commitChanges()
        vl_polygon.commitChanges()

        if vl_point.featureCount()>0 or vl_line.featureCount()>0 or vl_polygon.featureCount()>0:
            root = QgsProject.instance().layerTreeRoot()
            group = root.addGroup('Topology Checker')
            if vl_point.featureCount()>0:
                QgsProject.instance().addMapLayer(vl_point, False)
                group.addLayer(vl_point)
                pass
            if vl_line.featureCount()>0:
                QgsProject.instance().addMapLayer(vl_line, False)
                group.addLayer(vl_line)
                pass
            if vl_polygon.featureCount()>0:
                QgsProject.instance().addMapLayer(vl_polygon, False)
                group.addLayer(vl_polygon)
                pass
            pass

        return (vl_point.featureCount()+vl_line.featureCount()+vl_polygon.featureCount())

        pass

    def addFeatures(self,input,rule,target,output,pr,layerfeatcount,layererrorcount,errortype):
        self.layerlog(input, layerfeatcount, layererrorcount, errortype)
        for feat in output.getFeatures():
            #self.logWriting(input, rule, target,feat["id"] )
            fet = QgsFeature()
            fet.setGeometry(feat.geometry())
            fet.setAttributes([input, rule,target])
            pr.addFeatures([fet])
            pass
        pass

    def addError(self,input,rule,target,output,type):
        try:
            # x = requests.get(url, params=param)

            from PyQt5.QtSql import QSqlDatabase,QSqlQuery
            db = QSqlDatabase.addDatabase(self.data['dbtype'])
            db.setHostName(self.data['host'])
            db.setDatabaseName(self.data['db'])
            db.setPort(int(self.data['port']))
            db.setUserName(self.data['user'])
            db.setPassword(self.decrypt(self.data['pwd']))
            db_open=db.open()
            if not db_open:
                #print(db.lastError().databaseText())
                return
            input="'"+input+"'"
            rule = "'" + rule + "'"
            if target != None:
                target = "'" + target + "'"
                pass
            else:
                target="NULL"
            # query the table
            try:

                for feat in output.getFeatures():
                    geom_wkt = feat.geometry().asWkt()
                    qry = str(self.data['grid_id_query']).format(geom_wkt=geom_wkt)
                    #print(qry)
                    query1 = db.exec(qry)
                    if not query1.isActive() :
                        print(db.lastError().databaseText())
                        return
                    b = query1.next()
                    #print(b)
                    grid_id = query1.value(0)
                    #print(grid_id)
                    if grid_id != None:
                        grid_id = "'" + grid_id + "'"
                        pass
                    else:
                        grid_id = "''"

                    qry2 = str(self.data['insert_query']).format(input_lyr=input, error_type=rule, geom_wkt=geom_wkt,
                                                                geom_type=type, grid_id=grid_id, target_lyr=target)
                    #print(qry2)
                    query2 = db.exec(qry2)
                    #print(query2.lastError().databaseText())
                    query2.finish()
                    db.commit()
                    pass
            except:
                db.rollback()
                import traceback
                traceback.print_exc()
                pass
            pass
        except:
            import traceback
            traceback.print_exc()
            pass
        pass

    def decrypt(self,message):
        newS = ''
        for car in message:
            newS = newS + chr(ord(car) - 2)
        return newS

    def loadData(self):
        import json
        self.data = {}
        path2 = self.plugin_dir
        path = os.path.join(path2, "AppConfig.json")
        path=path.replace("\\","/")
        #print(path)
        try:
            if os.path.exists(path):
                with open(path) as json_file:
                    self.data = json.load(json_file)
                    pass
                # print (self.data)
                pass
        except Exception as e:
            err1 = "unable read data:-\n" + str(e)
            QMessageBox.information(None, 'Error', err1)
            import traceback
            traceback.print_exc()
            pass
            pass
        # return data
        pass

    def logWriting(self, input,rule,target,feat):
        now = datetime.now()
        s1 = now.strftime("%m/%d/%Y, %H:%M:%S")
        error=[input,rule,target,feat,s1]
        with open(newpath, 'a',newline= '') as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(error)

    def createNewfile(self):
        global newpath
        i = 0
        dirpath = os.path.join(os.path.dirname(__file__), 'data')
        for filename in os.listdir(dirpath):
            if filename.endswith(".csv") and filename.startswith("log"):
                x = filename.rsplit('.', 1)[0]
                y= x.split("_")
                if int(y[1])>i:
                    i = int(y[1])
            else:
                continue
        path = os.path.join(os.path.dirname(__file__), 'data', f"log_{i}.csv")
        Header = ["Source-Layers", "Topology_rules", "Target-Layers", "Feature-Id", "Date & Time"]
        while os.path.exists(path):
            i += 1
            break
        newpath = os.path.join(os.path.dirname(__file__), 'data', f"log_{i}.csv")
        with open(newpath, 'w') as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(Header)
        self.fileflag = True

    def layercount(self,layername):
        layer = self.getLayerByName(layername)
        if layer.featureCount is None :
            return 0
        else:
            return layer.featureCount()


    def getLayerByName(self, pstrLayerName):
        mc = self.iface.mapCanvas()
        nLayers = mc.layerCount()
        for l in range(nLayers):
            layer = mc.layer(l)
            if str(layer.name()) == pstrLayerName:
                return layer

    def layerlog(self,layername,ogcount,errcount,errorType):
        path = os.path.join(os.path.dirname(__file__), 'data','layerReport.csv')
        error = [layername,ogcount,errcount,errorType]
        with open(path, 'a',newline= '') as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(error)

    def createLayerLog(self):
        path = os.path.join(os.path.dirname(__file__), 'data', 'layerReport.csv')
        Header = ["Layer-name","Total-feature-count", "Total-error-count","ErrorType"]
        with open(path, 'w') as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(Header)


