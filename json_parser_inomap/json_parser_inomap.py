# -*- coding: utf-8 -*-
"""
/***************************************************************************
 JsonParserInomap
                                 A QGIS plugin
 convert json into postgres
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by genesys
        email                : pramoddb@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication,Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import*
from qgis.gui import *
from PyQt5.QtGui import *
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
# from import_Tool_dialog import importToolDialog
import os.path
import pyproj
import psycopg2
import json
import os
import sys
import datetime
from qgis.utils import iface
from qgis.core import Qgis
from.postgres_to_Json_parser import JsonParser1
from.Json_parser import JsonParser
from.Duplicatesegments import duplicate




# Import the code for the dialog
from .json_parser_inomap_dialog import JsonParserInomapDialog



class JsonParserInomap:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'JsonParserInomap_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Json Parser Inomap')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('JsonParserInomap', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/json_parser_inomap/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Json Parser Inomap'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Json Parser Inomap'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = JsonParserInomapDialog()
            self.con = DatabaseConnection(self.iface,self.dlg)
            self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
            self.dlg.dbcon.clicked.connect(self.con.dbconnect)
            self.dlg.dbsch.activated.connect(self.con.comboChange)
            self.dlg.imprun.clicked.connect(self.con.jsontopostgress)
            self.dlg.exprun.clicked.connect(self.con.postgresstojson)
            self.dlg.chkdup.clicked.connect(self.con.Checks_duplicated)
            

        # show the dialog
        self.dlg.show()
        self.refresh()
        # con = DatabaseConnection(self.iface,self.dlg)
        # self.dlg.dbcon.clicked.connect(self.con.dbconnect)
        # self.dlg.dbsch.activated.connect(self.con.comboChange)
        # self.dlg.imprun.clicked.connect(self.con.jsontopostgress)
        # self.dlg.exprun.clicked.connect(self.con.postgresstojson)
        # self.dlg.chkdup.clicked.connect(self.con.Checks_duplicated)
        # # Run the dialog event self.con
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
    def refresh(self):
        self.dlg.Imp.setEnabled(False)
        self.dlg.Exp.setEnabled(False)
        self.dlg.Duplicate_seg.setEnabled(False)
        self.dlg.progressBar.hide()
        self.dlg.label.hide()
        self.dlg.label_2.hide()
        self.dlg.label_3.hide()
        self.dlg.label_4.hide()
        self.dlg.label_5.hide()
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar_2.hide()
        self.dlg.progressBar_2.setValue(0)
        self.dlg.progressBar_3.hide()
        self.dlg.progressBar_3.setValue(0)
        self.dlg.dbuser.clear()
        self.dlg.dbpwd.clear()
        self.dlg.dbsch.clear()
        self.dlg.impcancel.hide()
        self.dlg.expcancel.hide()
        self.dlg.dupcancel.hide()
        self.dlg.impfilepath.lineEdit().clearValue()
        self.dlg.srcfilepath.lineEdit().clearValue()
        self.dlg.path.lineEdit().clearValue()
        
        
        
        
        



class DatabaseConnection:
    def __init__(self,iface,dlg):
        self.dlg = dlg
        self.iface = iface
        self.host = None
        self.port = None
        self.databas = None
        self.user = None
        self.pwd = None
        self.schem = None
        self.curs = None
        self.dirpath = None
        self.conn = None
        self.loadargs()

    def loadargs(self):
        try:
            path2 = os.path.dirname(__file__)
            path2 = path2.replace("\\", "/")
            path = os.path.join(path2, "AppConfig.json")
            if os.path.exists(path):
                with open(path, encoding='utf-8') as json_file:
                    data = json.load(json_file)
                    pass
                pass

        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            # print(exc_type, fname, exc_tb.tb_lineno)
        # print("data", data)
        databasestrings= data['database']
        # print("databasestrings", databasestrings)
        host = databasestrings['host']
        self.dlg.dbhost.setText(host)
        port = databasestrings['port']
        self.dlg.dbport.setText(port )
        databas = databasestrings['db']
        self.dlg.dbname.setText(databas)


    def dbconnect(self):
        '''Connecting to postgres database'''
        try:
            self.host = self.dlg.dbhost.text()
            self.port = self.dlg.dbport.text()
            self.databas = self.dlg.dbname.text()
            self.user = self.dlg.dbuser.text()
            self.pwd = self.dlg.dbpwd.text()
            if self.user=='inomap_curation_prod_user' : #or  self.pwd =='inomap_curation_prod@123'
                QMessageBox.critical(self.dlg,'Critical',"invalid username")
                return
            # self.schem.activated.connect(self.comboChange)
            # self.dlg.dbsch.activated.connect(self.comboChange)
            # jp=postgres_to_Json_parser(self)
        except Exception as e:
            QMessageBox.critical(self.dlg,'Critical',e)
        

        try:
            self.dlg.dbsch.clear()
            self.conn = psycopg2.connect(database=self.databas, user=self.user, password=self.pwd, host=self.host,port=int(self.port))
            
            # print("self.conn",self.conn)
            self.curs = self.conn.cursor()
            QMessageBox.information(self.dlg,'Information','Connected...')
            self.curs.execute("select schema_name from information_schema.schemata where schema_name not like 'p%' and schema_name NOT LIKE 'i%' and schema_name NOT LIKE 'm%' and schema_name <>'information_schema' order by schema_name;")
            # self.curs.execute("SELECT schema_name from information_schema.schemata")
            names = self.curs.fetchall()
            for name in names:
                self.dlg.dbsch.addItem(name[0])

            self.dlg.Imp.setEnabled(False)
            self.dlg.Exp.setEnabled(False)
            self.dlg.Duplicate_seg.setEnabled(True)
            self.dlg.path.setEnabled(True)

        except Exception as e:
            QMessageBox.critical(self.dlg,'Critical',"DB Not Connected \n check Credentails...")
        
    def jsontopostgress(self):
        # Get all child widgets of the dialog
        
        child_widgets = self.dlg.findChildren(QWidget)
        for widgetname in child_widgets:
            if type(widgetname) is QgsFileWidget and widgetname.objectName()=="impfilepath":
                self.dirpath=widgetname.filePath()
                if self.dirpath != '':
                    # jsonparser = JsonParser(self.dirpath, self)
                    jsonparser = JsonParser(self.dirpath, self,self.iface)
                    
                    dt_string = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
                    print('Endtime: ', dt_string)
                    

                    
                    
                else:
                    QMessageBox.information(self.dlg,'Information','Select the folder...')
    def postgresstojson(self):
        # Get all child widgets of the dialog
        
        child_widgets = self.dlg.findChildren(QWidget)
        for widgetname in child_widgets:
            if type(widgetname) is QgsFileWidget and widgetname.objectName()=="srcfilepath":
                self.dirpath=widgetname.filePath()
                if self.dirpath != '':
                    # print("self.dirpath",self.dirpath)
                    # jsonparser = JsonParser(self.dirpath, self)
                    # jp=postgres_to_Json_parser(self)
                    jsonparser = JsonParser1(self.dirpath,self,self.iface)
                    # QMessageBox.information(self.dlg,'Information','Data Exported Successfully.')
                        
                    dt_string = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
                    print('Endtime: ', dt_string)
                else:
                    QMessageBox.information(self.dlg,'Information','Select the folder...')

    def Checks_duplicated(self):
        # Get all child widgets of the dialog
        
        child_widgets = self.dlg.findChildren(QWidget)
        for widgetname in child_widgets:
            if type(widgetname) is QgsFileWidget and widgetname.objectName()=="path":
                self.dirpath=widgetname.filePath()
                if self.dirpath != '':
                    # print("self.dirpath",self.dirpath)
                    # jsonparser = JsonParser(self.dirpath, self)
                    # jp=postgres_to_Json_parser(self)
                    Chks_duplicated = duplicate(self.dirpath,self,self.iface)
                    # QMessageBox.information(self.dlg,'Information',' Checks_duplicated Successfully.')
                    dt_string = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
                    # print('Endtime: ', dt_string)
                else:
                    QMessageBox.information(self.dlg,'Information','Select the folder...')


    def comboChange(self):
        '''This is Schema Enable code'''
        # self.dlg.impcancel.clicked.connect(self.close)
        # self.dlg.expcancel.clicked.connect(self.close)
        self.schem = self.dlg.dbsch.currentText()
        self.msg()

 
     
    def close(self):
        self.dlg.close()

    def msg (self):
        # Create a QMessageBox instance
        msg_box = QMessageBox()
        # Set the message text
        msg_box.setText(f"Do you want to proceed?  {self.schem}")
        # Add "OK" and "Cancel" buttons
        msg_box.addButton(QMessageBox.Ok)
        msg_box.addButton(QMessageBox.Cancel)
        # Set the default button (in this case, "OK")
        msg_box.setDefaultButton(QMessageBox.Ok)
        msg_box.move(950, 300)
        # Execute the message box and get the result
        result = msg_box.exec_()
        # Check the result
        if result == QMessageBox.Ok:
            self.dlg.Imp.setEnabled(True)
            self.dlg.Exp.setEnabled(True)
            self.dlg.impfilepath.setEnabled(True)
            self.dlg.srcfilepath.setEnabled(True)
           
            
            # print("OK button was clicked")
        else:
           return
    def Lable_changed(self,counter,segment):
        self.dlg.label.show()
        self.dlg.label.setStyleSheet("border: none;")
        # self.dlg.label_2.hide()
        # Create a palette to set the text color
        palette = QPalette()
        text_color = QColor(47, 100, 223)  # Red color (RGB)
        palette.setColor(QPalette.Text, text_color) # Set the text color
        # palette.setColor(QPalette.WindowText, text_color)  

        # Apply the palette to the QLabel
        self.dlg.label.setPalette(palette)
        
        self.dlg.label.setText(f"     {counter} --- segment_id - {segment}")
        pass
    
    def Lable_2_changed(self,counter,segment):
        self.dlg.label_2.show()
        self.dlg.label_2.setStyleSheet("border: none;")
        # self.dlg.label_2_2.hide()
        # Create a palette to set the text color
        palette = QPalette()
        text_color = QColor(47, 100, 223)  # Red color (RGB)
        palette.setColor(QPalette.Text, text_color) # Set the text color
        # palette.setColor(QPalette.WindowText, text_color)  

        # Apply the palette to the Qlabel_2
        self.dlg.label_2.setPalette(palette)
        
        self.dlg.label_2.setText(f"     {counter} --- segment_id - {segment}")
        pass
    def Lable_3_changed(self,laneline_id,segment_id,laneline_id_to_seg):
        self.dlg.label_3.show()
        self.dlg.label_3.setStyleSheet("border: none;")
        # self.dlg.label_3_2.hide()
        # Create a palette to set the text color
        palette = QPalette()
        text_color = QColor(47, 100, 223)  # Red color (RGB)
        palette.setColor(QPalette.Text, text_color) # Set the text color
        # palette.setColor(QPalette.WindowText, text_color)  

        # Apply the palette to the Qlabel_3
        self.dlg.label_3.setPalette(palette)
        
        self.dlg.label_3.setText(f'      found duplicated lane line {laneline_id} in {segment_id} and {laneline_id_to_seg[laneline_id]}')
        # self.dlg.label_3.appendRow(list)
        pass

    def set_Lable_schema(self,schema_name):
        self.dlg.label_4.show()
        self.dlg.label_4.setStyleSheet("border: none;")
        # self.dlg.label_2.hide()
        # Create a palette to set the text color
        palette = QPalette()
        text_color = QColor(47, 100, 223)  # blue color (RGB)
        palette.setColor(QPalette.Text, text_color) # Set the text color
        # palette.setColor(QPalette.WindowText, text_color)  

        # Apply the palette to the QLabel
        self.dlg.label_4.setPalette(palette)
        
        self.dlg.label_4.setText(f"     Schema_name - ' {schema_name} '")

    def set_Lable_schema_2(self,schema_name):
        self.dlg.label_5.show()
        self.dlg.label_5.setStyleSheet("border: none;")
        # self.dlg.label_2.hide()
        # Create a palette to set the text color
        palette = QPalette()
        text_color = QColor(47, 100, 223)  # blue color (RGB)
        palette.setColor(QPalette.Text, text_color) # Set the text color
        # palette.setColor(QPalette.WindowText, text_color)  

        # Apply the palette to the QLabel
        self.dlg.label_5.setPalette(palette)
        
        self.dlg.label_5.setText(f"      Schema_name - ' {schema_name} '")






#for study bellow class
# class JsonParser:

#     def __init__(self, mainpath, Dbconnection):
#         try:
#             self.mainpath = mainpath
#             self.host = Dbconnection.host
#             self.database = Dbconnection.databas
#             self.user = Dbconnection.user
#             self.password = Dbconnection.pwd
#             self.port = int(Dbconnection.port)
#             self.db_link = Dbconnection.curs
#             self.connection_db = Dbconnection.conn
#             self.tbl_schema = Dbconnection.schem
#             self.dlg=Dbconnection.dlg
#             print("self.tbl_schema",self.tbl_schema)
            


            
#             self.file_name(self.mainpath)
            
            
           

#         except Exception as e:
#             exc_type, exc_obj, exc_tb = sys.exc_info()
#             fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
#             #print(exc_type, fname, exc_tb.tb_lineno)
#             iface.messageBar().pushMessage("Error",fname,level=Qgis.Critical)

#     def file_name_sublevel(self, dirpath):
#         try:
#             for path in dirpath:
#                 #print(path)
#                 return
#                 segments = []
#                 zones = []
#                 for file in os.listdir(path):
#                     if file.endswith('.segment') and (not file.startswith('._')):
#                         segments.append(path + '\\' + str(file))
#                     elif file.endswith('.zone') and (not file.startswith('._')):
#                         zones.append(path + '\\' + str(file))
#                 # if len(segments) > 0:
#                     self.segment_parser(segments)
#                 #     pass
#                     # print(segments)
#                 if len(zones) > 0:
#                     self.zone_parser(zones)
#                     pass
#                     # print(zones)
#         except Exception as e:
#             exc_type, exc_obj, exc_tb = sys.exc_info()
#             fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
#             iface.messageBar().pushMessage("Error",fname,level=Qgis.Critical)
#             # print(exc_type, fname, exc_tb.tb_lineno)

#     def file_name(self, dirpath):
#         try:
#             segments = []
#             zones = []
#             for file in os.listdir(dirpath):
#                 if file.endswith('.segment') and (not file.startswith('._')):
#                     segments.append(dirpath + '\\' + str(file))
#                 elif file.endswith('.zone') and (not file.startswith('._')):
#                     zones.append(dirpath + '\\' + str(file))
#             file_count=int(len(segments))
#             # print("count",count)
#             if len(segments) > 0:
#                 self.segment_parser(segments,file_count)
#                 pass
#                 #print(segments)
#             if len(zones) > 0:
#                 #print(zones)
#                 self.zone_parser(zones)
#                 pass
#                 #print(zones)
#             return
#         except Exception as e:
#             exc_type, exc_obj, exc_tb = sys.exc_info()
#             fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
#             #print(exc_type, fname, exc_tb.tb_lineno)
#             iface.messageBar().pushMessage("Error",fname,level=Qgis.Critical)

#     def segment_parser(self, segments,file_count):
#         self.dlg.progressBar.show()
#         item = QListWidgetItem()

#         try:
#             counter = 0
#             prg = 0 
#             for segment in segments:
#                 counter = counter + 1
#                 # print(segment)
#                 with open(segment) as f:
#                     data = json.load(f)
#                 segment_id = ''
#                 nav_path_id = ''
#                 speed_limit = ''
#                 #preferred_speed_limit = ''
#                 road_code = ''
                

#                 for key, value in data.items():

#                     # print(key, value)
#                     if key == 'id':
#                         segment_id = data[key]['s']
#                         print(counter," - segment_id",segment_id)
#                         # Dbconnection.Lable_changed(segment_id)
#                         # item.setText(segment_id)
#                         # self.dlg.listWidget.addItem(item)
#                     if key == 'nav_path_id':
#                         nav_path_id = data[key]['s']
#                         # print(nav_path_id)
#                     if key == 'road_class':
#                         # print("data[key]",data[key])
#                         if isinstance(data[key], int):
#                             # print("test")
#                             # print("data[key]",data[key])
#                             sql4 ="select description  from  {self.tbl_schema}.road_class where id ='{0}' ;".format(data[key])
#                             self.db_link.execute(sql4)
#                             road_code_class_desc  = self.db_link.fetchone()[0]
#                             # print("road_class_desc",road_code_class_desc)
#                             data[key]=road_code_class_desc
#                             # print("data[key]",data[key])
#                         road_code_class = data[key].capitalize()
#                         # if data[key]is_integer()==True:
#                         #     road_code_class = data[key]
#                         # else:
#                         #     road_code_class = data[key].capitalize()

#                         road_code_class = road_code_class.split('(')
#                         # print(str(road_code_class[0]))
#                         sql = "SELECT id from " + self.tbl_schema + "." + "road_class where description = " + "'" + \
#                               str(road_code_class[0]) + "'"

#                         # print("sql",sql)
#                         self.db_link.execute(sql)
#                         road_code = self.db_link.fetchone()[0]
#                         # road_code = road_code_class
#                         # print("road_code",road_code)
#                         # return
#                     if key == 'speed_limit':
#                         speed_limit = data[key]
#                         # print(speed_limit)
                    
#                     if key == 'lanes':
#                         lanes = data[key]
#                         for lane in range(len(lanes)):
#                             lane_id = ''
#                             left_lane_line_id = ''
#                             right_lane_line_id = ''
#                             # maybe_left_lane_line_reversed_id = ''
#                             # maybe_right_lane_line_reversed_id = ''
#                             left_adj_lane_id = ''
#                             right_adj_lane_id = ''
#                             lane_class = ''
#                             lane_direction = ''
                            
#                             for lane_key in lanes[lane]:
#                                 if lane_key == 'id':
#                                     lane_id = lanes[lane][lane_key]['s']
#                                     #print(lane_id)

#                                 if lane_key == 'left_lane_line_id':
#                                     left_lane_line_id = lanes[lane][lane_key]['s']
#                                     # print(left_lane_line_id)
#                                     # return

#                                 if lane_key == 'right_lane_line_id':
#                                     right_lane_line_id = lanes[lane][lane_key]['s']
#                                     # print(right_lane_line_id)

                               
#                                 if lane_key == 'left_adj_lane_id':
#                                     left_adj_lane_id = lanes[lane][lane_key]['s']
#                                     # print(left_adj_lane_id)

#                                 if lane_key == 'right_adj_lane_id':
#                                     right_adj_lane_id = lanes[lane][lane_key]['s']
#                                     # print(right_adj_lane_id)

#                                 if lane_key == 'transitions':
#                                     transition_num = 0
#                                     for transition in lanes[lane][lane_key]:
#                                         transition_id = ''
#                                         entrance_id = ''
#                                         exit_id = ''
                                        
#                                         for transition_key in transition:

#                                             if transition_key == 'id':
#                                                 transition_id = lanes[lane][lane_key][transition_num][transition_key]['s']
#                                                 # print(transition_id)

#                                             if transition_key == 'entrance':
#                                                 entrance_id = lanes[lane][lane_key][transition_num][transition_key]['s']
#                                                 # print(entrance_id)

#                                             if transition_key == 'exit':
#                                                 # print(transition_num)
#                                                 exit_id = lanes[lane][lane_key][transition_num][transition_key]['s']
#                                                 # print(exit_id)

                                            

#                                         transition_num+= 1

#                                         tabl = 'transitions'

#                                         sql3 = "insert into " + self.tbl_schema + "." + tabl + " (transition_id,entrance_id,exit_id) " \
#                                                                                                "values (%s,%s,%s)"
#                                         # sql3 = "insert into " + self.tbl_schema + "." + tabl + " (transition_id,entrance_id,exit_id,zone,ref_path,control_type,turn_type,entrance_endside,exit_endside,meta_has_qc,meta_fake,meta_preferred,meta_has_traffic_guard,right_of_way,oncoming_traffic,no_turn_on_red,ego_non_drivable) " \
#                                         #                                                       "values (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
#                                         # print("sql3",sql3)

#                                         self.db_link.execute(sql3, (
#                                             str(transition_id), str(entrance_id), str(exit_id)))

                                       
#                                         self.connection_db.commit()

#                                 if lane_key == 'lane_class':
#                                     lane_class = lanes[lane][lane_key]
#                                     # print(lane_class)

#                                 if lane_key == 'lane_direction':
#                                     lane_direction = lanes[lane][lane_key]
#                                     # print(lane_direction)

#                                 if lane_key == 'meta':
#                                     lane_meta_has_qc = lanes[lane][lane_key]['has_qc']
#                                     lane_meta_fake = lanes[lane][lane_key]['fake']
#                                     lane_meta_preferred = lanes[lane][lane_key]['preferred']
#                                     lane_meta_has_traffic_guard = lanes[lane][lane_key]['has_traffic_guard']

#                                     # print(lane_meta)

#                                 if lane_key == 'num_total_transitions':
#                                     num_total_transitions = lanes[lane][lane_key]
#                                     # print(num_total_transitions)
#                             tabl = 'lanes'
#                             sql3 = "insert into " + self.tbl_schema + "." + tabl + " (lane_id,left_lane_id,right_lane_id,left_adj_lane_id,right_adj_lane_id,lane_class,lane_direction,segment_id) " \
#                                                                                    "values (%s,%s,%s,%s,%s,%s,%s,%s)"
                            
#                             self.db_link.execute(sql3, (
#                                 str(lane_id), str(left_lane_line_id), str(right_lane_line_id),
#                                 str(left_adj_lane_id), str(right_adj_lane_id), str(lane_class), str(lane_direction),
#                                 str(segment_id)))
                           
#                             self.connection_db.commit()
#                     if key == 'lane_lines':
#                         lane_lines = data[key]
#                         # with open(id + '.csv', 'w', encoding='UTF8', newline='') as f:
#                         for lane_line in range(len(lane_lines)):
#                             # header = ['index', 'lane_line_key', 'Lat', 'Long', 'altitude']
#                             # writer = csv.writer(f)
#                             # writer.writerow(header)
#                             lane_line_key_id = ''
#                             lane_line_type = ''
#                             # lane_line_meta_has_qc = ''
#                             # lane_line_meta_fake = ''
#                             # lane_line_meta_preferred = ''
#                             # lane_line_meta_has_traffic_guard = ''
#                             line_cordinate = []
#                             for lane_line_key in lane_lines[lane_line]:
#                                 index = 1
#                                 if lane_line_key == 'id':
#                                     lane_line_key_id = lane_lines[lane_line][lane_line_key]['s']
#                                     # print(lane_line_key_id)
#                                     lane_line_inde = lane_line_key_id

#                                 if lane_line_key == 'polyline':
#                                     polyline = lane_lines[lane_line][lane_line_key]['waypoints']
#                                     for point in polyline:
#                                         x = point['matrix'][0][0]
#                                         y = point['matrix'][0][1]
#                                         z = point['matrix'][0][2]
#                                         index += 1
#                                         lat1, lon1, alt1 = self.transform(x, y, z)
#                                         cord = [lat1, lon1, alt1]
#                                         line_cordinate.append(cord)
#                                         # print(lat1, lon1, alt1)
#                                         # row = [index, lane_line_inde, lat1, lon1, alt1]
#                                         # writer.writerow(row)

#                                 if lane_line_key == 'type':
#                                     lane_line_type = lane_lines[lane_line][lane_line_key]
#                                     # print(lane_line_type)

                               
#                             # print(line_cordinate)
#                             tabl = 'lane_lines'
#                             # print(line_cordinate)
#                             points = []
#                             for i in line_cordinate:
#                                 sql1 = f"SELECT st_makepoint{str(i[0]), str(i[1]), str(i[2])}"
#                                 # print(sql1)
#                                 self.db_link.execute(sql1)
#                                 points.append(self.db_link.fetchall())
#                             geomstring = ''
#                             points_len = len(points)
#                             count = 0
#                             for point in points:
#                                 count += 1
#                                 for p in point:
#                                     if count < points_len:
#                                         geomstring += str("'" + p[0] + "'" + ",")
#                                     else:
#                                         geomstring += str("'" + p[0] + "'")
#                             sql2 = f"SELECT ST_MakeLine(ARRAY[{geomstring}])"
#                             # print(sql2)
#                             self.db_link.execute(sql2)
#                             lane_geom = self.db_link.fetchall()
#                             # print(segment_geom)

#                             sql3 = "insert into " + self.tbl_schema + "." + tabl + " (lane_id,geom,type) " \
#                                                                                    "values (%s,%s,%s)"

#                             # sql3 = "insert into " + self.tbl_schema + "." + tabl + " (lane_id,geom,type,meta_has_qc,meta_fake,meta_preferred,meta_has_traffic_guard) " \
#                             #                                                        "values (%s,%s,%s,%s,%s,%s,%s)"

#                             # print(sql3)
#                             self.db_link.execute(sql3, (
#                                 str(lane_line_key_id), lane_geom[0][0], str(lane_line_type)))

#                             self.connection_db.commit()
#                 tabl = 'segment'
#                 sql3 = "insert into " + self.tbl_schema + "." + tabl + " (segment_id,nav_path_id,road_code,speed_limit) " \
#                                                                        "values (%s,%s,%s,%s)"
#                 # sql3 = "insert into " + self.tbl_schema + "." + tabl + " (segment_id,nav_path_id,road_code,speed_limit,preferred_speed_limit,adjusted_speed_limit,meta_has_qc,meta_fake,meta_preferred,meta_has_traffic_guard,lane_line_directions_resolved) " \
#                 #                                                        "values (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
#                 # print(sql3)
#                 self.db_link.execute(sql3, (
#                     str(segment_id), str(nav_path_id), str(road_code),
#                     str(speed_limit)))
               
#                 self.connection_db.commit()
#                 percent = prg / float(file_count) * 100
#                 self.dlg.progressBar.setValue(percent)
#                 prg += 1
#             self.dlg.progressBar.setValue(0)
#             self.dlg.progressBar.hide()
#         except Exception as e:
#             # print(e)
#             exc_type, exc_obj, exc_tb = sys.exc_info()
#             fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
#             #print(exc_type, fname, exc_tb.tb_lineno)
#             iface.messageBar().pushMessage("Error Seg ID - ",str(segment_id),level=Qgis.Critical)
#             self.connection_db.rollback()

#     def zone_parser(self, zones):
#         try:
#             for zone in zones:
#                 with open(zone) as f:
#                     # print(zone)
#                     data = json.load(f)
#                     line_cordinate = []
#                     zone_id = ''
#                     meta_has_qc = ''
#                     meta_fake = ''
#                     meta_preferred = ''
#                     meta_has_traffic_guard = ''
#                     edge_meta_is_crosswalk_entrance = ''
#                     edge_meta_is_crossable = ''
#                     traffic_lights = ''
#                     type = ''
#                     sub_zones = ''
#                     for key, value in data.items():
#                         if key == 'id':
#                             zone_id = data[key]['s']
#                             # print(zone_id)

                       
#                         if key == 'boundaries':
#                             edges = data[key][0]['edges'][0]['waypoints']
                            
#                             index = 1

#                             for edge in edges:
#                                 x = edge['matrix'][0][0]
#                                 y = edge['matrix'][0][1]
#                                 z = edge['matrix'][0][2]
#                                 index += 1
#                                 lat1, lon1, alt1 = self.transform(x, y, z)
#                                 cord = [str(lat1), str(lon1), str(alt1)]
#                                 line_cordinate.append(cord)
                             

#                         if key == 'type':
#                             type = data[key]
#                             # print(type_Intersection)

                       
#                     tabl = 'zone'
#                     # print(line_cordinate)
#                     points = []
#                     for i in line_cordinate:
#                         sql1 = f"SELECT st_makepoint{str(i[0]), str(i[1]), str(i[2])}"
#                         # print(sql1)
#                         self.db_link.execute(sql1)
#                         points.append(self.db_link.fetchall())

#                     geomstring = ''
#                     points_len = len(points)
#                     count = 0
#                     for point in points:
#                         count += 1
#                         for p in point:
#                             if count < points_len:
#                                 geomstring += str("'" + p[0] + "'" + ",")
#                             else:
#                                 geomstring += str("'" + p[0] + "'")

#                     sql2 = f"SELECT ST_MakeLine(ARRAY[{geomstring}])"
#                     # print(sql2)
#                     self.db_link.execute(sql2)
#                     zone_geom = self.db_link.fetchall()
                    

#                     sql3 = "insert into " + self.tbl_schema + "." + tabl + " (zone_id,type,geom) " \
#                                                                            "values (%s,%s,%s)"
#                     #print(sql3)
#                     print(str(zone_id),  str(type),
#                           str(zone_geom[0][0]))
#                     self.db_link.execute(sql3, (
#                         str(zone_id), str(type),
#                         zone_geom[0][0]))
#                     #print(str(zone_id), str(meta_has_qc),str(meta_fake),str(meta_preferred),str(meta_has_traffic_guard),str(edge_meta_is_crosswalk_entrance),str(edge_meta_is_crossable),str(traffic_lights),str(type),str(sub_zones),str(zone_geom[0][0]))

#                     self.connection_db.commit()

#         except Exception as e:
#             exc_type, exc_obj, exc_tb = sys.exc_info()
#             fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
#             #print(exc_type, fname, exc_tb.tb_lineno)
#             iface.messageBar().pushMessage("Error",str(zone_id),level=Qgis.Critical)
#             self.connection_db.rollback()

#     def transform(self, x, y, z):
#         transformer = pyproj.Transformer.from_crs(
#             {"proj": 'geocent', "ellps": 'WGS84', "datum": 'WGS84'},
#             {"proj": 'latlong', "ellps": 'WGS84', "datum": 'WGS84'},

#         )
#         lon1, lat1, alt1 = transformer.transform(x, y, z, radians=False)
#         return lon1, lat1, alt1
