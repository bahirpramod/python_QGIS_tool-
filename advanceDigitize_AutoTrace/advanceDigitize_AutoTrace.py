# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AdvanceDigitize_AutoTrace
                                 A QGIS plugin
 An editing tool for QGIS that allows users to 'trace' new 
    feature geometry based on existing features Advanced Digitizing Polygon and Polyline and Option for drawing convex hull
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-01-23
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Genesys
        email                : gulabm@email.igenesys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from qgis.core import *
from qgis.gui import *
import sys
import qgis
from .fill_gap import FillGap
from PyQt5.QtCore import QObject

# initialize Qt resources from file resources.py
# import resources

#Import own tools
from .vertexTracerTool import VertexTracerTool

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
# from .advanceDigitize_AutoTrace_dialog import AdvanceDigitize_AutoTraceDialog
import os.path


class AdvanceDigitize_AutoTrace:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()
        self.list_layer = []
        self.lineSplitPoly = False
        self.fillRing = False
        self.reshapePolygon = False
        self.polyLayer = None
        self.polyFeature = None
        self.reTain = False
        self.event_Connect = False

    def initGui(self):
        mc = self.canvas
        layer = mc.currentLayer()

        self.rubberBand = 0

        # Create an action for getting help
        # self.helpAction = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/iconAutoTrace.png"), "Help", self.iface.mainWindow())
        # QObject.connect(self.helpAction, SIGNAL("triggered()"), self.openHelp)
        #self.menu = self.iface.pluginMenu().addMenu(QIcon(":/plugins/AdvanceDigitize_AutoTrace/iconAutoTrace.png"), "AdvanceDigitize_AutoTrace")
        # self.menu.addAction(self.helpAction)

        # Create action that will start plugin configuration
        self.action = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/iconAutoTrace.png"),
                              "Advance-Digitize-Auto-trace", self.iface.mainWindow())
        self.action.setEnabled(False)
        self.action.setCheckable(True)
        self.action.setChecked(False)

        # Create action for splitting polygon with line (line has anglelock)
        self.split_action = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/split.png"), "Split In Valid Angle",
                                    self.iface.mainWindow())
        self.split_action.setEnabled(False)
        self.split_action.setCheckable(True)
        self.split_action.setChecked(False)

        # Create action for splitting polygon with polygon
        self.splitpoly_action = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/splitpoly.png"), "Fill Ring",
                                        self.iface.mainWindow())
        self.splitpoly_action.setEnabled(False)
        self.splitpoly_action.setCheckable(True)
        self.splitpoly_action.setChecked(False)

        # Create action for reshaping polygon with line
        self.reshapePoly_action = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/reshapePoly.png"),
                                          "Reshape Polygons", self.iface.mainWindow())
        self.reshapePoly_action.setEnabled(False)
        self.reshapePoly_action.setCheckable(True)
        self.reshapePoly_action.setChecked(False)

        # Create action to fill gaps within polygons
        self.fillGap_action = QAction(QIcon(":/plugins/AdvanceDigitize_AutoTrace/fill.png"), "Fill Gap",
                                      self.iface.mainWindow())
        self.fillGap = FillGap(self, self.fillGap_action)
        self.fillGap_action.setEnabled(False)
        self.fillGap_action.setCheckable(True)
        self.fillGap_action.setChecked(False)

        # Connect to signals for button behaviour
        # QObject.connect(self.action, SIGNAL("triggered()"), self.run)

        self.action.triggered.connect(self.run)
        self.split_action.triggered.connect(self.split)
        self.splitpoly_action.triggered.connect(self.polygonFillRing)
        self.reshapePoly_action.triggered.connect(self.reshapePoly)
        self.fillGap_action.triggered.connect(self.fillGap.run)
        # self.fillGap_action.triggered.connect(self.fillGap.run)
        # QObject.connect(self.split_action, SIGNAL("triggered()"), self.split)
        # QObject.connect(self.splitpoly_action, SIGNAL("triggered()"), self.polygonFillRing)
        # QObject.connect(self.reshapePoly_action, SIGNAL("triggered()"), self.reshapePoly)
        # QObject.connect(self.fillGap_action, SIGNAL("triggered()"), self.fillGap.run)
        # QObject.connect(self.iface, SIGNAL("currentLayerChanged(QgsMapLayer*)"), self.change_layer)
        self.iface.currentLayerChanged.connect(self.change_layer)
        # QObject.connect(mc, SIGNAL("mapToolSet(QgsMapTool*)"), self.deactivate)
        self.iface.mapCanvas().mapToolSet.connect(self.deactivate)

        # Add toolbar button

        self.iface.digitizeToolBar().addAction(self.action)
        self.iface.digitizeToolBar().addAction(self.split_action)
        self.iface.digitizeToolBar().addAction(self.splitpoly_action)
        self.iface.digitizeToolBar().addAction(self.reshapePoly_action)
        self.iface.digitizeToolBar().addAction(self.fillGap_action)
        self.addMyDockWidget()
        # Get the Tool
        self.tool = VertexTracerTool(self)

    def addMyDockWidget(self):
        # Create a dock widget for the input fields (note that the dockwidget is only added to the mainWindow when the tool is activated)
        self.dockWidget = QDockWidget("Digitize Tool")
        self.dockWidget.setFeatures(QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable)
        self.dockLayout = QGridLayout()
        self.dockLayout.setColumnStretch(1, 10)
        self.dockLayout.setRowStretch(3, 10)
        dockWidgetMainWidget = QWidget()
        self.dockWidget.setWidget(dockWidgetMainWidget)
        dockWidgetMainWidget.setLayout(self.dockLayout)
        self.iface.mainWindow().addDockWidget(Qt.LeftDockWidgetArea, self.dockWidget)
        self.dockWidget.hide()

        # Create and setup the input elements
        # spinBoxDist - Showing current Segment Distance
        self.spinBoxDist = QDoubleSpinBox()
        self.spinBoxDist.setValue(10.00)
        self.spinBoxDist.setDecimals(8)
        self.spinBoxDist.setMinimum(-9999999.999)
        self.spinBoxDist.setMaximum(9999999.999)

        # lockBoxDist - Lock for length of segment
        self.lockBoxDist = QCheckBox()
        self.lockBoxDist.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")
        # QObject.connect(self.lockBoxDist, SIGNAL("stateChanged(int)"), self.OnStateChanged_lockBoxDist)
        self.lockBoxDist.stateChanged.connect(self.OnStateChanged_lockBoxDist)

        # spinBoxDist_Min - set Minimum Distance of Segment
        self.spinBoxDist_Min = QDoubleSpinBox()
        self.spinBoxDist_Min.setValue(0.000006)
        self.spinBoxDist_Min.setDecimals(8)
        self.spinBoxDist_Min.setMinimum(-9999999.999)
        self.spinBoxDist_Min.setMaximum(9999999.999)
        self.spinBoxDist_Min.setValue(0.000006)
        # QObject.connect(self.spinBoxDist_Min, SIGNAL("valueChanged(double)"), self.OnvalueChanged_spinBoxDist_Min)
        self.spinBoxDist_Min.valueChanged.connect(self.OnvalueChanged_spinBoxDist_Min)
        # self.lockBoxDist_Min = QCheckBox()
        # self.lockBoxDist_Min.setStyleSheet( "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }" )

        # spinBoxDist_Max - set Maximum Distance of Segment
        self.spinBoxDist_Max = QDoubleSpinBox()
        self.spinBoxDist_Max.setValue(0.01)
        self.spinBoxDist_Max.setDecimals(8)
        self.spinBoxDist_Max.setMinimum(-9999999.999)
        self.spinBoxDist_Max.setMaximum(9999999.999)
        # QObject.connect(self.spinBoxDist_Max, SIGNAL("valueChanged(double)"), self.OnvalueChanged_spinBoxDist_Max)
        self.spinBoxDist_Max.valueChanged.connect(self.OnvalueChanged_spinBoxDist_Max)

        # lockBoxDist_Max - Lock for Min and Maximum Distance of segment
        self.lockBoxDist_Max = QCheckBox()
        self.lockBoxDist_Max.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")
        # QObject.connect(self.lockBoxDist_Max, SIGNAL("stateChanged(int)"), self.OnStateChanged_lockBoxDist_Max)
        self.lockBoxDist_Max.stateChanged.connect(self.OnStateChanged_lockBoxDist_Max)
        self.lockBoxDist_Max.toggle()

        # spinBoxAngle - Set Angle Value
        self.spinBoxAngle = QDoubleSpinBox()
        self.spinBoxAngle.setValue(0.00)
        self.spinBoxAngle.setDecimals(2)
        self.spinBoxAngle.setMinimum(-360.0)
        self.spinBoxAngle.setMaximum(360.0)
        # self.spinBoxAngle.setSuffix(unichr(176))
        # lockBoxAngle relBox -Lock for Fix angle and second Showing Angle Value in Ral with previous Segment
        self.lockBoxAngle = QCheckBox()
        self.lockBoxAngle.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")
        self.relBox = QCheckBox()
        self.relBox.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/delta.png); }")
        self.relBox.setChecked(True)
        # spinBoxLockAngleTolerance : Set angle Tolerance Value
        self.spinBoxLockAngleTolerance = QDoubleSpinBox()
        self.spinBoxLockAngleTolerance.setValue(9.9)
        self.spinBoxLockAngleTolerance.setDecimals(2)
        self.spinBoxLockAngleTolerance.setMinimum(1.0)
        self.spinBoxLockAngleTolerance.setMaximum(180.0)
        # self.spinBoxLockAngleTolerance.setSuffix(unichr(176))
        # lockBoxAngleTolerance : Lock for angle Tolerance
        self.lockBoxAngleTolerance = QCheckBox()
        self.lockBoxAngleTolerance.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")
        # QObject.connect(self.lockBoxAngleTolerance, SIGNAL("stateChanged(int)"),
        #                 self.OnStateChanged_lockBoxAngleTolerance)
        self.lockBoxAngleTolerance.stateChanged.connect(self.OnStateChanged_lockBoxAngleTolerance)
        self.lockBoxAngleTolerance.toggle()

        self.lockBoxAngle90 = QCheckBox()
        self.lockBoxAngle90.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/on_90_1.png);} QCheckBox::indicator:unchecked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/off_90_1.png);}")

        # lockBoxConvexHullGeom : Lock for ConvexHull
        self.lockBoxConvexHullGeom = QCheckBox()
        self.lockBoxConvexHullGeom.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")

        # arc tool
        self.spinBoxPreVertexCount = QDoubleSpinBox()
        self.spinBoxPreVertexCount.setValue(4)
        self.spinBoxPreVertexCount.setDecimals(0)
        self.spinBoxPreVertexCount.setMinimum(1)
        self.spinBoxPreVertexCount.setMaximum(50)

        self.spinBoxBufferValue = QDoubleSpinBox()
        self.spinBoxBufferValue.setValue(1)
        self.spinBoxBufferValue.setDecimals(2)
        self.spinBoxBufferValue.setMinimum(0.1)
        self.spinBoxBufferValue.setMaximum(15)
        self.spinBoxBufferValue.setEnabled(False)

        self.lockBoxPreVertex = QCheckBox()
        self.lockBoxPreVertex.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/curve_on.png);} QCheckBox::indicator:unchecked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/curveOff.png);}")
        # QObject.connect(self.lockBoxPreVertex, SIGNAL("stateChanged(int)"), self.OnStateChanged_lockBoxPreVertex)
        self.lockBoxPreVertex.stateChanged.connect(self.OnStateChanged_lockBoxPreVertex)

        self.lockBoxbuffer = QCheckBox()
        self.lockBoxbuffer.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/buffer_on_1.png);} QCheckBox::indicator:unchecked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/buffer_off.png);}")
        # QObject.connect(self.lockBoxbuffer, SIGNAL("stateChanged(int)"), self.OnStateChanged_lockBoxbuffer)
        self.lockBoxbuffer.stateChanged.connect(self.OnStateChanged_lockBoxbuffer)
        self.lockBoxbuffer.setEnabled(False)

        # lockBoxShowVertexSymbol : Lock for showing Vertex Symbol
        self.lockBoxShowVertexSymbol = QCheckBox()
        self.lockBoxShowVertexSymbol.setStyleSheet(
            "QCheckBox::indicator:checked{ image: url(:/plugins/AdvanceDigitize_AutoTrace/Image/lock.png); }")
        # QObject.connect(self.lockBoxShowVertexSymbol, SIGNAL("stateChanged(int)"),
        #                 self.OnStateChanged_lockBoxShowVertexSymbol)
        self.lockBoxShowVertexSymbol.stateChanged.connect(self.OnStateChanged_lockBoxShowVertexSymbol)

        # Layout the input elements
        self.dockLayout.addWidget(QLabel('Distance'), 0, 0)
        self.dockLayout.addWidget(self.spinBoxDist, 0, 1)
        self.dockLayout.addWidget(self.lockBoxDist, 0, 2)
        self.dockLayout.addWidget(QLabel('Min Dist'), 1, 0)
        self.dockLayout.addWidget(self.spinBoxDist_Min, 1, 1)

        self.dockLayout.addWidget(QLabel('Max Dist'), 2, 0)
        self.dockLayout.addWidget(self.spinBoxDist_Max, 2, 1)
        self.dockLayout.addWidget(self.lockBoxDist_Max, 2, 2)

        self.dockLayout.addWidget(QLabel('Angle'), 3, 0)
        self.dockLayout.addWidget(self.spinBoxAngle, 3, 1)
        self.dockLayout.addWidget(self.lockBoxAngle, 3, 2)
        self.dockLayout.addWidget(self.relBox, 3, 3)
        self.dockLayout.addWidget(QLabel('Lock Tolerance(+-)'), 4, 0)
        self.dockLayout.addWidget(self.spinBoxLockAngleTolerance, 4, 1)
        self.dockLayout.addWidget(self.lockBoxAngleTolerance, 4, 2)
        self.dockLayout.addWidget(self.lockBoxAngle90, 4, 3)

        lbl = QLabel('Convex Hull')
        lbl.setStyleSheet(
            "QLabel { color: rgb(119, 27, 90); font-size: 15px; background-color: rgba(188, 188, 188, 50); border: 1px solid rgba(188, 188, 188, 250); } QSpinBox { color: rgb(50, 50, 50); font-size: 11px; background-color: rgba(255, 188, 20, 50); }")
        self.lblConvexhullarea = QLabel()
        self.lblConvexhullarea.setStyleSheet(
            "QLabel { color: rgb(25-25-112); font-size: 10px; background-color: rgba(188, 188, 188, 50); border: 1px solid rgba(188, 188, 188, 250); } QSpinBox { color: rgb(50, 50, 50); font-size: 8px; background-color: rgba(255, 188, 20, 50); }")
        self.dockLayout.addWidget(self.lblConvexhullarea, 5, 0)
        self.dockLayout.addWidget(lbl, 5, 1)
        self.dockLayout.addWidget(self.lockBoxConvexHullGeom, 5, 2)

        self.dockLayout.addWidget(QLabel('Arc'), 6, 0)
        self.dockLayout.addWidget(self.spinBoxPreVertexCount, 6, 1)
        self.dockLayout.addWidget(self.lockBoxPreVertex, 6, 2)

        self.dockLayout.addWidget(QLabel('Buffer'), 7, 0)
        self.dockLayout.addWidget(self.spinBoxBufferValue, 7, 1)
        self.dockLayout.addWidget(self.lockBoxbuffer, 7, 2)

        self.dockLayout.addWidget(QLabel('Show Vertex Symbol'), 8, 1)
        self.dockLayout.addWidget(self.lockBoxShowVertexSymbol, 8, 2)

        # Create tooltips
        self.spinBoxDist.setToolTip('Distance (alt+7)')
        self.spinBoxAngle.setToolTip('Angle (alt+8)')
        self.lockBoxDist.setToolTip('Lock distance (shift+alt+7)')
        self.lockBoxAngle.setToolTip('Lock angle (shift+alt+8)')
        self.relBox.setToolTip('Absolute angle (shift+alt+10)')
        self.spinBoxLockAngleTolerance.setToolTip('Lock Tolerance (F2)')
        self.lockBoxAngleTolerance.setToolTip('angle Tolerance (F4)')
        self.lockBoxConvexHullGeom.setToolTip('Enabled to Draw convex hull (shift+C)')
        self.lockBoxAngle90.setToolTip('Lock angle at 90 (shift+alt+9)')
        lbl.setToolTip('Enabled to Draw convex hull (shift+C)')
        self.spinBoxPreVertexCount.setToolTip('No of Segment In Cureve and buffer')
        self.spinBoxBufferValue.setToolTip('buffer size')
        self.lockBoxPreVertex.setToolTip('Onoff Pre Cureve Line')
        self.lockBoxPreVertex.setToolTip('On off Buffer Line')

        # Create shortcuts

        QShortcut(QKeySequence("alt+7"), self.iface.mapCanvas()).activated.connect(self.focusDist)
        QShortcut(QKeySequence("alt+8"), self.iface.mapCanvas()).activated.connect(self.focusAngle)
        QShortcut(QKeySequence("shift+alt+7"), self.iface.mapCanvas()).activated.connect(self.toggleLockDist)
        QShortcut(QKeySequence("shift+alt+8"), self.iface.mapCanvas()).activated.connect(self.toggleLockAngle)
        QShortcut(QKeySequence("f2"), self.iface.mapCanvas()).activated.connect(self.focusAngleTolerance)
        QShortcut(QKeySequence("f4"), self.iface.mapCanvas()).activated.connect(self.toggleLockTolerance)
        QShortcut(QKeySequence("shift+alt+9"), self.iface.mapCanvas()).activated.connect(self.toggle90Lock)
        QShortcut(QKeySequence("shift+C"), self.iface.mapCanvas()).activated.connect(self.toggleConvax)
        QShortcut(QKeySequence("shift+alt+10"), self.iface.mapCanvas()).activated.connect(self.toggleAbsAngle)
        # QShortcut(QKeySequence("shift+alt+12"), self.iface.mapCanvas()).activated.connect(self.toggleArc_Vtx)
        # QShortcut(QKeySequence("shift+alt+13"), self.iface.mapCanvas()).activated.connect(self.toggleShow_Vtx)
        # QObject.connect(QShortcut(QKeySequence("alt+7"), self.iface.mapCanvas()), SIGNAL("activated()"), self.focusDist)
        # QObject.connect(QShortcut(QKeySequence("alt+8"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.focusAngle)
        # QObject.connect(QShortcut(QKeySequence("shift+alt+7"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggleLockDist)
        # QObject.connect(QShortcut(QKeySequence("shift+alt+8"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggleLockAngle)
        # QObject.connect(QShortcut(QKeySequence("shift+alt+10"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggleAbsAngle) 33333333
        # QObject.connect(QShortcut(QKeySequence("f2"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.focusAngleTolerance)
        # QObject.connect(QShortcut(QKeySequence("f4"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggleLockTolerance)
        # QObject.connect(QShortcut(QKeySequence("shift+C"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggleConvax)
        # QObject.connect(QShortcut(QKeySequence("shift+alt+9"), self.iface.mapCanvas()), SIGNAL("activated()"),
        #                 self.toggle90Lock)

    def OnStateChanged_lockBoxPreVertex(self, state):
        if self.tool is None:
            return

    def OnStateChanged_lockBoxbuffer(self, state):
        if self.tool is None:
            return

    def OnStateChanged_lockBoxShowVertexSymbol(self, state):
        if self.tool is None:
            return
        if state == 2:
            self.tool.IsShowVertexSymbol = True
            self.tool.addAllVertexMarker()
        else:
            self.tool.clearVertexMarker()
            self.tool.IsShowVertexSymbol = False

    def toggle90Lock(self):
        self.lockBoxAngle90.toggle()

    def toggleConvax(self):
        self.lockBoxConvexHullGeom.toggle()

    def OnvalueChanged_spinBoxDist_Max(self, value):
        try:
            self.spinBoxDist_Min.setMaximum(value)
        except:
            QgsMessageLog.logMessage("OnvalueChanged_spinBoxDist_Max", "AdvanceDigitize_AutoTrace", 2)

    def OnvalueChanged_spinBoxDist_Min(self, value):
        try:
            self.spinBoxDist_Max.setMinimum(value)
        except:
            QgsMessageLog.logMessage("OnvalueChanged_spinBoxDist_Min", "AdvanceDigitize_AutoTrace", 2)

    def OnStateChanged_lockBoxDist_Max(self, state):
        if state == 2:
            self.lockBoxDist.setCheckState(0)

    def OnStateChanged_lockBoxDist(self, state):
        if state == 2:
            self.lockBoxDist_Max.setCheckState(0)

    def OnStateChanged_lockBoxAngleTolerance(self, state):
        # print('state ghm', state)
        if state == 2:
            self.relBox_ = self.relBox.checkState()
            self.lockBoxAngle_ = self.lockBoxAngle.checkState()
            self.angle_ = self.spinBoxAngle.value()
            self.lockBoxAngle.setCheckState(0)
            self.relBox.setCheckState(0)
            self.lockBoxAngle.setEnabled(False)
            self.relBox.setEnabled(True)

        else:
            self.lockBoxAngle.setCheckState(self.lockBoxAngle_)
            self.relBox.setCheckState(self.relBox_)
            self.spinBoxAngle.setValue(self.angle_)
            self.lockBoxAngle.setEnabled(True)
            self.relBox.setEnabled(True)

    def focusAngleTolerance(self):
        self.spinBoxLockAngleTolerance.setFocus()
        self.spinBoxLockAngleTolerance.selectAll()

    def toggleLockTolerance(self):
        self.lockBoxAngleTolerance.toggle()

    def focusAngle(self):
        """
        Gives the focus to angle input (used for by the shortcut action)
        """
        self.spinBoxAngle.setFocus()
        self.spinBoxAngle.selectAll()

    def focusDist(self):
        """
        Gives the focus to distance input (used for by the shortcut action)
        """
        self.spinBoxDist.setFocus()
        self.spinBoxDist.selectAll()

    def toggleLockAngle(self):
        """
        Toggles the angle lock (used for by the shortcut action)
        """
        if self.lockBoxAngleTolerance.isChecked():
            return
        self.lockBoxAngle.toggle()

    def toggleLockDist(self):
        """
        Toggles the distance lock (used for by the shortcut action)
        """
        self.lockBoxDist.toggle()

    def toggleAbsAngle(self):
        """
        Toggles the distance lock (used for by the shortcut action)
        """
        self.relBox.toggle()

    def unload(self):
        if self.dockWidget is not None:
            self.dockWidget.hide()
        self.dockWidget = None
        self.iface.digitizeToolBar().removeAction(self.action)
        self.iface.digitizeToolBar().removeAction(self.split_action)
        self.iface.digitizeToolBar().removeAction(self.splitpoly_action)
        self.iface.digitizeToolBar().removeAction(self.reshapePoly_action)
        self.iface.digitizeToolBar().removeAction(self.fillGap_action)
        # self.menu.removeAction(self.helpAction)
        # self.iface.pluginMenu().removeAction(self.menu.menuAction())

    def openHelp(self):
        # Open the help page
        QDesktopServices.openUrl(QUrl(''))

    def change_layer(self):
        QgsMessageLog.logMessage("change_layer", "AdvanceDigitize_AutoTrace", Qgis.Info)
        isBind = False

        for ly in self.list_layer:
            if ly.bindEvent():
                isBind = True
                break;
        if isBind == False:
            mc = self.canvas
            layer = mc.currentLayer()
            if layer != None:
                if layer.type() == 0:  # Vector Layer
                    self.list_layer.append(LayerEvent(self))
                else:
                    self.action.setEnabled(False)
                    self.split_action.setEnabled(False)
                    self.splitpoly_action.setEnabled(False)
                    self.reshapePoly_action.setEnabled(False)
                    self.fillGap_action.setEnabled(False)
            else:
                self.action.setEnabled(False)
                self.split_action.setEnabled(False)
                self.splitpoly_action.setEnabled(False)
                self.reshapePoly_action.setEnabled(False)
                self.fillGap_action.setEnabled(False)

    def toggle(self):
        mc = self.canvas
        layer = mc.currentLayer()
        QgsMessageLog.logMessage("toggle", "AdvanceDigitize_AutoTrace")
        # Decide whether the plugin button/menu is enabled or disabled
        if layer != None:
            if layer.isEditable() and (layer.geometryType() == 1 or layer.geometryType() == 2):
                self.action.setEnabled(True)
                self.split_action.setEnabled(True)
                self.splitpoly_action.setEnabled(True)
                self.reshapePoly_action.setEnabled(True)
                self.fillGap_action.setEnabled(True)
                QgsMessageLog.logMessage("StartEvent editingStopped", "AdvanceDigitize_AutoTrace")
                # QObject.connect(layer,SIGNAL("editingStopped()"),self.toggle)
                # QObject.disconnect(layer,SIGNAL("editingStarted()"),self.toggle)

            else:
                self.action.setEnabled(False)
                self.split_action.setEnabled(False)
                self.splitpoly_action.setEnabled(False)
                self.reshapePoly_action.setEnabled(False)
                self.fillGap_action.setEnabled(False)
                QgsMessageLog.logMessage("StartEvent editingStarted", "AdvanceDigitize_AutoTrace")
                # QObject.connect(layer,SIGNAL("editingStarted()"),self.toggle)
                # QObject.disconnect(layer,SIGNAL("editingStopped()"),self.toggle)

    def deactivate(self):
        # uncheck the button/menu and get rid off the VTTool signal
        QgsMessageLog.logMessage("deactivate", "AdvanceDigitize_AutoTrace", Qgis.Info)
        if self.canvas.mapTool():
            QgsMessageLog.logMessage("deactivate:- active Tool:-" + str(self.canvas.mapTool().toolName()),
                                     "AdvanceDigitize_AutoTrace", Qgis.Info)
        if self.canvas.mapTool() and (
                self.canvas.mapTool().toolName() == "Advance-Digitize-Auto-trace") and self.reTain:
            QgsMessageLog.logMessage("deactivate:- continue", "AdvanceDigitize_AutoTrace", Qgis.Info)
            self.reTain = False
        else:
            if self.canvas.mapTool():
                if self.canvas.mapTool().action() != None:
                    if self.canvas.mapTool() and (self.canvas.mapTool().toolName() in ("mycustomeCursorTool", "Pan") \
                                                  or (
                                                          "Measure " in self.canvas.mapTool().action().text())) and self.tool.started == True:
                        self.reTain = True
                    else:
                        self.reTain = False
                        self.tool.reset()
                QgsMessageLog.logMessage("deactivate:- retain active this tool " + str(self.reTain),
                                         "AdvanceDigitize_AutoTrace", Qgis.Info)

        if self.canvas.mapTool() and (
                self.canvas.mapTool().toolName() != "Advance-Digitize-Auto-trace"):  # and self.reTain  ==False:
            QgsMessageLog.logMessage("deactivate:- reset", "AdvanceDigitize_AutoTrace", Qgis.Info)
            self.split_action.setChecked(False)
            self.splitpoly_action.setChecked(False)
            self.reshapePoly_action.setChecked(False)
            self.action.setChecked(False)
            self.fillGap_action.setChecked(False)
            if self.dockWidget is not None:
                self.dockWidget.hide()
            # QObject.disconnect(self.tool, SIGNAL("traceFound(PyQt_PyObject)"), self.createFeature)
            # self.tool.traceFound.disconnect(self.createFeature)
            self.event_Connect = False
            self.lineSplitPoly = False
            self.reshapePolygon = False
            self.fillRing = False

    def run(self):
        # Here we go...
        mc = self.canvas
        layer = mc.currentLayer()

        # bring our tool into action
        mc.setMapTool(self.tool)

        self.action.setChecked(True)

        # Show the dockWidget, give it the focus, and display the tool as checked
        self.dockWidget.show()
        self.focusDist()
        # Connect to the VTtool
        if self.event_Connect == False:
            # QObject.connect(self.tool, SIGNAL("traceFound(PyQt_PyObject)"), self.createFeature) by gulab
            self.event_Connect = True

        # Warn if there are no snapable layers
    #     if self.snappableLayerCount() < 1:
    #         self.iface.messageBar().pushMessage("AdvanceDigitize_AutoTrace", \
    #                                             "None of the enabled layers have snapping enabled - AdvanceDigitize_AutoTrace needs snappable layers in order to trace.",
    #                                             level=QgsMessageBar.WARNING)
    #
    # def snappableLayerCount(self):
    #     count = 0
    #     proj = QgsProject.instance()
    #     for layer in self.iface.mapCanvas().layers():  # Visible layers
    #         if proj.snapSettingsForLayer(layer.id())[1]:
    #             count += 1
    #     return count

    def validateLayer(self, layer, task):
        # QObject.disconnect(self.iface, SIGNAL("currentLayerChanged(QgsMapLayer*)"), self.toggle)
        try:
            self.iface.currentLayerChanged.disconnect(self.toggle)
        except:
            pass
        isValid = True
        if not layer:
            isValid = False
        elif task == 'reshapeGeometry' and layer.geometryType() == 0:
            isValid = False
        elif (task == 'addRingPolygon' or task == 'split') and layer.geometryType() != 2:
            isValid = False

        if isValid == False:
            if (task == 'addRingPolygon' or task == 'split'):
                QMessageBox.information(None, 'Select Layer', 'Please select polygon layer')
            else:
                QMessageBox.information(None, 'Select Layer', 'Please select polygon/polyline layer')
            self.split_action.setChecked(False)
            self.splitpoly_action.setChecked(False)
            self.reshapePoly_action.setChecked(False)
            self.fillGap_action.setChecked(False)
            self.iface.actionTouch().trigger()
        return isValid

    def split(self):
        QgsMessageLog.logMessage('split', 'AdvanceDigitize_AutoTrace')
        self.split_action.setChecked(True)
        self.splitpoly_action.setChecked(False)
        self.reshapePoly_action.setChecked(False)
        self.fillGap_action.setChecked(False)
        self.lineSplitPoly = True
        self.reshapePolygon = False
        self.fillRing = False
        layer = self.canvas.currentLayer()
        isValidLayer = self.validateLayer(layer, 'split')
        if isValidLayer:
            self.polyLayer = layer
            self.action.trigger()

    def splitPolygon(self, line_geom):
        QgsMessageLog.logMessage('splitPolygon', 'AdvanceDigitize_AutoTrace')
        self.lineSplitPoly = False
        self.reshapePolygon = False
        self.fillRing = False
        QgsMessageLog.logMessage('line_geom - ' + str(line_geom), 'AdvanceDigitize_AutoTrace')
        QgsMessageLog.logMessage('line_geom line - ' + str(line_geom.asPolyline()), 'AdvanceDigitize_AutoTrace')
        QgsMessageLog.logMessage('line_geom type - ' + str(line_geom.type()), 'AdvanceDigitize_AutoTrace')
        try:
            result = self.polyLayer.splitFeatures(line_geom.asPolyline(), True)
            QgsMessageLog.logMessage('result - ' + str(result), 'AdvanceDigitize_AutoTrace')
            if result == 4:
                QMessageBox.information(None, 'Split', "No features were split. An error occurred during splitting. " +
                                        "If there are selected features, the split tool only applies to those. " +
                                        "If you would like to split all features under the split line, clear the selection.")
            elif result == 3:
                QMessageBox.information(None, 'Split',
                                        'No feature split done. Cut edges detected. Make sure the line splits features into multiple parts.')
            elif result == 7:
                QMessageBox.information(None, 'Split',
                                        'No feature split done. The geometry is invalid. Please repair before trying to split it.')
            elif result != 0:
                QMessageBox.information(None, 'Split', 'No feature split done. An error occurred during splitting.')
        except:
            QgsMessageLog.logMessage("unable to splitPolygon Error:-" + str(sys.exc_info()),
                                     "AdvanceDigitize_AutoTrace", QgsMessageLog.CRITICAL)
        finally:
            self.iface.mapCanvas().refresh()
            self.split_action.setChecked(False)
            self.splitpoly_action.setChecked(False)
            self.reshapePoly_action.setChecked(False)
            self.fillGap_action.setChecked(False)
            # self.iface.actionTouch().trigger()

    def polygonFillRing(self):
        QgsMessageLog.logMessage('polygonFillRing', 'AdvanceDigitize_AutoTrace')
        self.splitpoly_action.setChecked(True)
        self.split_action.setChecked(False)
        self.reshapePoly_action.setChecked(False)
        self.fillGap_action.setChecked(False)
        self.lineSplitPoly = False
        self.reshapePolygon = False
        self.fillRing = True
        layer = self.canvas.currentLayer()
        isValidLayer = self.validateLayer(layer, 'addRingPolygon')
        if isValidLayer:
            self.polyLayer = layer
            self.action.trigger()

    def addRingPolygon(self, geom):
        QgsMessageLog.logMessage('addRingPolygon', 'AdvanceDigitize_AutoTrace')
        self.fillRing = False
        self.lineSplitPoly = False
        self.reshapePolygon = False
        points = None
        if geom.wkbType() == QgsWkbTypes.Polygon:
            points = geom.asPolygon()[0]
        elif geom.wkbType() == QgsWkbTypes.MultiPolygon:
            points = geom.asMultiPolygon()[0][0]
        QgsMessageLog.logMessage('points - ' + str(points), 'AdvanceDigitize_AutoTrace')
        try:
            result = self.polyLayer.addRing(points)
        except:
            QgsMessageLog.logMessage("addRing Error:-" + str(sys.exc_info()), "AdvanceDigitize_AutoTrace",
                                     QgsMessageLog.CRITICAL)
        QgsMessageLog.logMessage('result - ' + str(result), 'AdvanceDigitize_AutoTrace')
        if result[0] == 0:
            iterator = self.polyLayer.getFeatures(QgsFeatureRequest().setFilterFid(result[1]))
            for i in iterator:
                polyFeature = i
                break
            QgsMessageLog.logMessage('polyFeature - ' + str(polyFeature), 'AdvanceDigitize_AutoTrace')
            # feature = QgsFeature()
            # feature.setGeometry(geom)
            # feature.setFields(self.polyLayer.fields())
            # feature.setAttributes(polyFeature.attributes())
            # feature.setAttribute(0, self.polyLayer.defaultValue(0))
            # # feature.setAttribute("seasonality", '')
            # # feature.setAttribute("inland", '')
            # # feature.setAttribute("display_class", '')
            # self.polyLayer.addFeature(feature)
            self.canvas.refresh()
            QMessageBox.information(None, 'Fill Ring',
                                    'Success: feature with ID = ' + str(int(result[1])) + ' modified')
        elif result[0] == 1:
            QMessageBox.information(None, 'Fill Ring', 'A problem with geometry type occurred')
        elif result[0] == 2:
            QMessageBox.information(None, 'Fill Ring', 'The inserted Ring is not closed')
        elif result[0] == 3:
            QMessageBox.information(None, 'Fill Ring', 'The inserted Ring is not a valid geometry')
        elif result[0] == 4:
            QMessageBox.information(None, 'Fill Ring', 'The inserted Ring crosses existing rings')
        elif result[0] == 5:
            QMessageBox.information(None, 'Fill Ring', 'The inserted Ring is not contained in a feature')
        else:
            QMessageBox.information(None, 'Fill Ring', 'Unknown error occured')
        self.split_action.setChecked(False)
        self.splitpoly_action.setChecked(False)
        self.reshapePoly_action.setChecked(False)
        self.fillGap_action.setChecked(False)
        # self.iface.actionTouch().trigger()

    def reshapePoly(self):
        QgsMessageLog.logMessage('reshapePolygon', 'AdvanceDigitize_AutoTrace')
        self.reshapePoly_action.setChecked(True)
        self.splitpoly_action.setChecked(False)
        self.split_action.setChecked(False)
        self.fillGap_action.setChecked(False)
        self.lineSplitPoly = False
        self.fillRing = False
        self.reshapePolygon = True
        layer = self.canvas.currentLayer()
        isValidLayer = self.validateLayer(layer, 'reshapeGeometry')
        if isValidLayer:
            self.polyLayer = layer
            self.action.trigger()

    def reshapePolygonByLine(self, geom):
        QgsMessageLog.logMessage('reshapePolygonByLine', 'AdvanceDigitize_AutoTrace')
        self.fillRing = False
        self.lineSplitPoly = False
        self.reshapePolygon = False
        underlying_features = []
        firstPoint = geom.asPolyline()[0]
        QgsMessageLog.logMessage('geom.asPolyline() - ' + str(geom.asPolyline()), 'AdvanceDigitize_AutoTrace')
        QgsMessageLog.logMessage('firstPoint - ' + str(firstPoint), 'AdvanceDigitize_AutoTrace')
        bbox = QgsRectangle(firstPoint.x(), firstPoint.y(), firstPoint.x(), firstPoint.y())
        for i in range(1, len(geom.asPolyline())):
            bbox.combineExtentWith(geom.asPolyline()[i].x(), geom.asPolyline()[i].y())
        ##        rb = QgsRubberBand(self.canvas, QGis.Line)
        ##        rb.setColor(QColor(255,0,0,90))
        ##        rb.setWidth(1)
        ##        rb.setToGeometry(QgsGeometry().fromRect(bbox), self.polyLayer)
        ##        rb.show()
        iterator = self.polyLayer.getFeatures(QgsFeatureRequest().setFilterRect(bbox))
        for i in iterator:
            underlying_features.append(i)
        QgsMessageLog.logMessage('underlying_features len - ' + str(len(underlying_features)),
                                 'AdvanceDigitize_AutoTrace')
        for feature in underlying_features:
            QgsMessageLog.logMessage('feature id - ' + str(feature.id()), 'AdvanceDigitize_AutoTrace')
            feat_geom = feature.geometry()
            line = QgsLineString([QgsPoint(i) for i in geom.asPolyline()])
            # print('geom.asPolyline()',line)
            reshape_success = feat_geom.reshapeGeometry(line)
            if reshape_success == 0:
                if feat_geom.isEmpty():
                    QMessageBox.information(None, 'Reshape Polygons',
                                            'The feature cannot be reshaped because the resulting geometry is empty')
                    self.polyLayer.destroyEditCommand()
                    # self.iface.actionTouch().trigger()
                    return
                self.polyLayer.changeGeometry(feature.id(), feat_geom)
                QgsMessageLog.logMessage('success', 'AdvanceDigitize_AutoTrace')
            else:
                QgsMessageLog.logMessage('failure', 'AdvanceDigitize_AutoTrace')
        ##                QMessageBox.information(None, 'Reshape Polygons', 'Reshaping Failed!')

        self.split_action.setChecked(False)
        self.splitpoly_action.setChecked(False)
        self.reshapePoly_action.setChecked(False)
        self.fillGap_action.setChecked(False)
        # self.iface.actionTouch().trigger()

    def createFeature(self, geom):
        if not geom:
            return False  # invalid geometry (e.g. just one point for a polyline)

        layer = self.canvas.currentLayer()
        provider = layer.dataProvider()
        fields = provider.fields()
        f = QgsFeature(fields)

        errors = geom.validateGeometry()
        if len(errors) == 0:
            f.setGeometry(geom)
            if self.lineSplitPoly:
                self.splitPolygon(geom)
                return
            if self.fillRing:
                self.addRingPolygon(geom)
                return
            if self.reshapePolygon:
                self.reshapePolygonByLine(geom)
                return
        else:
            if self.fillRing or self.reshapePolygon:
                self.fillRing = False
                self.lineSplitPoly = False
                self.reshapePolygon = False
                self.split_action.setChecked(False)
                self.splitpoly_action.setChecked(False)
                self.reshapePoly_action.setChecked(False)
                self.fillGap_action.setChecked(False)
                self.iface.actionTouch().trigger()
                QMessageBox.information(self.iface.mainWindow(), 'Feature not valid',
                                        "The geometry of the feature you just added isn't valid.")
                return
            # Concatenate errors into a string
            errorsString = ""
            intersection_points = []
            for error in errors:
                locationString = "[" + str(error.where().x()) + "," + str(error.where().y()) + "]"
                errorsString += error.what()
                errorsString += "\n  "
                errorsString += locationString
                errorsString += "\n"
                if 'intersect' in error.what():
                    intersection_points.append(tuple([error.where().x(), error.where().y()]))
            reply = QMessageBox.question(self.iface.mainWindow(), 'Feature not valid',
                                         "The geometry of the feature you just added isn't valid. Do you want to use it anyway?\n\n" +
                                         "Errors were:\n\n" +
                                         errorsString,
                                         QMessageBox.Yes, QMessageBox.No)
            if reply == QMessageBox.Yes:
                f.setGeometry(geom)
                if self.lineSplitPoly:
                    if ('intersect' in errorsString) and (len(intersection_points) > 0):
                        QgsMessageLog.logMessage('geom as polyline - ' + str(geom.asPolyline()),
                                                 'AdvanceDigitize_AutoTrace', Qgis.Info)
                        QgsMessageLog.logMessage('intersection_points - ' + str(intersection_points),
                                                 'AdvanceDigitize_AutoTrace', Qgis.Info)
                        intersection_points.extend(geom.asPolyline()[1:-1])
                        QgsMessageLog.logMessage('intersection_points - ' + str(intersection_points),
                                                 'AdvanceDigitize_AutoTrace', Qgis.Info)
                        coords = []
                        for p in intersection_points:
                            coords.append(self.canvas.mapRenderer().mapToLayerCoordinates(layer, QgsPoint(p[0], p[1])))
                        new_geom = QgsGeometry().fromPolygon([coords])
                        QgsMessageLog.logMessage('new_geom - ' + str(new_geom.asPolygon()), 'AdvanceDigitize_AutoTrace',
                                                 Qgis.Info)
                        self.addRingPolygon(new_geom)
                        self.split_action.setChecked(False)
                        self.splitpoly_action.setChecked(False)
                        self.reshapePoly_action.setChecked(False)
                        self.fillGap_action.setChecked(False)
                        self.iface.actionTouch().trigger()
                        return
            else:
                if self.lineSplitPoly:
                    self.fillRing = False
                    self.lineSplitPoly = False
                    self.reshapePolygon = False
                    self.split_action.setChecked(False)
                    self.splitpoly_action.setChecked(False)
                    self.reshapePoly_action.setChecked(False)
                    self.fillGap_action.setChecked(False)
                    self.iface.actionTouch().trigger()
                return False

        # this is the preferred way of adding features in QGIS >= 2.4
        # it respects default values, suppression of attribute form, reuse of recent values etc.
        if int(Qgis.QGIS_VERSION[0]) >= 3:
            QgsMessageLog.logMessage("QGis.QGIS_VERSION_INT >= 20400", "AdvanceDigitize_AutoTrace", Qgis.Info)
            if self.iface.vectorLayerTools().addFeature(layer, {}, geom):
                self.canvas.refresh()
                return True
            else:
                return False

        # compatibility code for older versions: QGIS < 2.4
        QgsMessageLog.logMessage("older versions: QGIS < 2.4", "AdvanceDigitize_AutoTrace", Qgis.Info)
        layer.beginEditCommand("Feature added")
        layer.addFeature(f)

        # let the user set some attributes
        if not self.iface.openFeatureForm(layer, f):
            layer.destroyEditCommand()
            return False

        layer.endEditCommand()

        self.canvas.refresh()


class LayerEvent:
    def __init__(self, parent):
        self.parent = parent
        mc = self.parent.canvas
        self.layer = mc.currentLayer()
        self.BindeditingEvent = False
        self.id = None
        if self.layer != None:
            # self.layer.layerDeleted.connect(self.onDeleted) by gulab
            self.id = self.layer.id()
        self.bindEvent()

    def bindEvent(self):
        if self.layer != None:
            mc = self.parent.canvas
            layer = mc.currentLayer()
            if layer != None and self.layer.id() == layer.id():
                if self.BindeditingEvent == False:
                    self.BindeditingEvent = True
                    # QObject.connect(self.layer, SIGNAL("editingStopped()"), self.onEditing_Staet_Stopped)
                    # QObject.connect(self.layer, SIGNAL("editingStarted()"), self.onEditing_Staet_Stopped)
                    self.layer.editingStopped.connect(self.onEditing_Staet_Stopped)
                    self.layer.editingStarted.connect(self.onEditing_Staet_Stopped)
                self.onEditing_Staet_Stopped()
                return True
        return False

    def onEditing_Staet_Stopped(self):
        if self.layer != None:
            if self.layer.isEditable() and (self.layer.geometryType() == 1 or self.layer.geometryType() == 2):
                self.parent.action.setEnabled(True)
                self.parent.split_action.setEnabled(True)
                self.parent.splitpoly_action.setEnabled(True)
                self.parent.reshapePoly_action.setEnabled(True)
                self.parent.fillGap_action.setEnabled(True)
                QgsMessageLog.logMessage(self.layer.id() + " onEditing_Start", "AdvanceDigitize_AutoTrace",
                                         Qgis.Info)
            else:
                self.parent.action.setEnabled(False)
                self.parent.split_action.setEnabled(False)
                self.parent.splitpoly_action.setEnabled(False)
                self.parent.reshapePoly_action.setEnabled(False)
                self.parent.fillGap_action.setEnabled(False)
                QgsMessageLog.logMessage(self.layer.id() + " onEditing_Stopped", "AdvanceDigitize_AutoTrace",
                                         Qgis.Info)

    def onDeleted(self):
        self.layer = None
        QgsMessageLog.logMessage(str(self.id) + " onDeleted", "AdvanceDigitize_AutoTrace", Qgis.Info)

